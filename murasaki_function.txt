// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;



//---------------------------------------------------------------------------------------------------------------------
//Ownable

/**
 * @dev Provides information about the current execution context, including the
 * sender of the transaction and its data. While these are generally available
 * via msg.sender and msg.data, they should not be accessed in such a direct
 * manner, since when dealing with meta-transactions the account sending and
 * paying for execution may not be the actual sender (as far as an application
 * is concerned).
 *
 * This contract is only required for intermediate, library-like contracts.
 */
abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}

/**
 * @dev Contract module which provides a basic access control mechanism, where
 * there is an account (an owner) that can be granted exclusive access to
 * specific functions.
 *
 * By default, the owner account will be the one that deploys the contract. This
 * can later be changed with {transferOwnership}.
 *
 * This module is used through inheritance. It will make available the modifier
 * `onlyOwner`, which can be applied to your functions to restrict their use to
 * the owner.
 */
abstract contract Ownable is Context {
    address private _owner;
    RandomDataGuard internal _rdg;
    string internal _planetsBaseURI;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /**
     * @dev Initializes the contract setting the deployer as the initial owner.
     */
    constructor() {
        _setOwner(_msgSender());
    }

    /**
     * @dev Returns the address of the current owner.
     */
    function owner() public view virtual returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        require(owner() == _msgSender(), "Ownable: caller is not the owner");
        _;
    }
    
    function setRDG(address rdg)public virtual onlyOwner {
        _rdg = RandomDataGuard(rdg);    
    }

    function setBaseURI(string memory pBaseURI)public virtual onlyOwner {
        _planetsBaseURI = pBaseURI;    
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        _setOwner(newOwner);
    }

    function _setOwner(address newOwner) private {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}

interface RandomDataGuard {
    function randomGuard(uint256 random) external view returns(uint256);
}


interface murasaki_main {
    function summon(address, uint32) external returns (uint32);
    function ownerOf(uint32) external returns (address);
}

interface murasaki_strage {
    function level(uint32) external view returns (uint32);
    function exp(uint32) external view returns (uint32);
    function strength(uint32) external view returns (uint32);
    function dexterity(uint32) external view returns (uint32);
    function intelligence(uint32) external view returns (uint32);
    function luck(uint32) external view returns (uint32);
    function next_exp_required(uint32) external view returns (uint32);
    function last_level_up_time(uint32) external view returns (uint32);
    function coin(uint32) external view returns (uint32);
    function material(uint32) external view returns (uint32);
    function last_feeding_time(uint32) external view returns (uint32);
    function last_grooming_time(uint32) external view returns (uint32);
    function mining_status(uint32) external view returns (uint32);
    function mining_start_time(uint32) external view returns (uint32);
    function farming_status(uint32) external view returns (uint32);
    function farming_start_time(uint32) external view returns (uint32);
    function crafting_status(uint32) external view returns (uint32);
    function crafting_start_time(uint32) external view returns (uint32);
    function crafting_item_type(uint32) external view returns (uint32);
    function total_mining_sec(uint32) external view returns (uint32);
    function total_farming_sec(uint32) external view returns (uint32);
    function total_crafting_sec(uint32) external view returns (uint32);
    function last_total_mining_sec(uint32) external view returns (uint32);
    function last_total_farming_sec(uint32) external view returns (uint32);
    function last_total_crafting_sec(uint32) external view returns (uint32);
    function last_grooming_time_plus_working_time(uint32) external view returns (uint32);
    function set_level(uint32, uint32) external;
    function set_exp(uint32, uint32) external;
    function set_strength(uint32, uint32) external;
    function set_dexterity(uint32, uint32) external;
    function set_intelligence(uint32, uint32) external;
    function set_luck(uint32, uint32) external;
    function set_next_exp_required(uint32, uint32) external;
    function set_last_level_up_time(uint32, uint32) external;
    function set_coin(uint32, uint32) external;
    function set_material(uint32, uint32) external;
    function set_last_feeding_time(uint32, uint32) external;
    function set_last_grooming_time(uint32, uint32) external;
    function set_mining_status(uint32, uint32) external;
    function set_mining_start_time(uint32, uint32) external;
    function set_farming_status(uint32, uint32) external;
    function set_farming_start_time(uint32, uint32) external;
    function set_crafting_status(uint32, uint32) external;
    function set_crafting_start_time(uint32, uint32) external;
    function set_crafting_item_type(uint32, uint32) external;
    function set_total_mining_sec(uint32, uint32) external;
    function set_total_farming_sec(uint32, uint32) external;
    function set_total_crafting_sec(uint32, uint32) external;
    function set_last_total_mining_sec(uint32, uint32) external;
    function set_last_total_farming_sec(uint32, uint32) external;
    function set_last_total_crafting_sec(uint32, uint32) external;
    function set_last_grooming_time_plus_working_time(uint32, uint32) external;
}


//---------------------------------------------------------------------------------------------------------------------
//Murasaki Function

contract Murasaki_Function is Ownable {

    //address
    address public murasaki_strage_address;
    address public murasaki_main_address;

    //variants
    uint32 public BASE_SEC = 86400;
    uint32 public SPEED = 1;
    uint32 public PRICE = 0 ether;

    //admin
    function _set_base_sec(uint32 _base_sec) external onlyOwner {
        BASE_SEC = _base_sec;
    }
    function _set_speed(uint32 _speed) external onlyOwner {
        SPEED = _speed;
    }
    function _set_murasaki_strage_address(address _address) external onlyOwner {
        murasaki_strage_address = _address;
    }
    function _set_murasaki_main_address(address _address) external onlyOwner {
        murasaki_main_address = _address;
    }
    function set_price(uint8 _price) external onlyOwner {
        PRICE = _price;
    }

    //admin. withdraw
    function withdraw(address rec)public onlyOwner{
        payable(rec).transfer(address(this).balance);
    }

    //contract
    //Murasaki_Main mm = Murasaki_Main(murasaki_main_address);
    //Murasaki_Strage ms = Murasaki_Strage(murasaki_strage_address);
    murasaki_main mm = murasaki_main(murasaki_main_address);
    murasaki_strage ms = murasaki_strage(murasaki_strage_address);

    //summon, only from murasaki_main
    function summon(uint32 _class) external payable {
        require(msg.value >= PRICE);
        require(0 <= _class && _class <= 11);
        //summon on mm, mint NTT
        //Murasaki_Main mm = Murasaki_Main(murasaki_main_address);
        uint32 _summoner = mm.summon(msg.sender, _class);
        //summon on ms, initialize sutatus
        //Murasaki_Strage ms = Murasaki_Strage(murasaki_strage_address);
        uint32 _now = uint32(block.timestamp);
        ms.set_level(_summoner, 1);
        ms.set_exp(_summoner, 0);
        ms.set_strength(_summoner, 500);
        ms.set_dexterity(_summoner, 500);
        ms.set_intelligence(_summoner, 500);
        ms.set_luck(_summoner, 500);
        ms.set_next_exp_required(_summoner, 1000);
        ms.set_last_level_up_time(_summoner, _now);
        ms.set_coin(_summoner, 0);
        ms.set_material(_summoner, 0);
        ms.set_last_feeding_time(_summoner, _now - BASE_SEC/4);
        ms.set_last_grooming_time(_summoner, _now - BASE_SEC/4);
        ms.set_mining_status(_summoner, 0);
        ms.set_mining_start_time(_summoner, 0);
        ms.set_farming_status(_summoner, 0);
        ms.set_farming_start_time(_summoner, 0);
        ms.set_crafting_status(_summoner, 0);
        ms.set_crafting_start_time(_summoner, 0);
        ms.set_crafting_item_type(_summoner, 0);
        ms.set_total_mining_sec(_summoner, 0);
        ms.set_total_farming_sec(_summoner, 0);
        ms.set_total_crafting_sec(_summoner, 0);
        ms.set_last_total_mining_sec(_summoner, 0);
        ms.set_last_total_farming_sec(_summoner, 0);
        ms.set_last_total_crafting_sec(_summoner, 0);
        ms.set_last_grooming_time_plus_working_time(_summoner, _now - BASE_SEC/4);
    }

    //feeding
    function feeding(uint32 _summoner) external {
        //Murasaki_Main mm = Murasaki_Main(murasaki_main_address);
        //Murasaki_Strage ms = Murasaki_Strage(murasaki_strage_address);
        require(mm.ownerOf(_summoner) == msg.sender);
        uint32 _now = uint32(block.timestamp);
        uint32 _exp = ms.exp(_summoner);
        uint32 _satiety = calc_feeding(_summoner);
        _exp += 1000 * (100 - _satiety) / 100;
        ms.set_exp(_summoner, _exp);
        ms.set_last_feeding_time(_summoner, _now);
    }
    function calc_feeding(uint32 _summoner) public view returns (uint32) {
        //Murasaki_Strage ms = Murasaki_Strage(murasaki_strage_address);
        uint32 _now = uint32(block.timestamp);
        uint32 _delta_sec = _now - ms.last_feeding_time(_summoner);
        uint32 _base = BASE_SEC /2 /SPEED;
        uint32 _satiety;
        if (_delta_sec >= _base) {
            _satiety = 0;
        }else {
            _satiety = 100 * (_base - _delta_sec) / _base;
        }
        return _satiety;
    }

    //grooming
    function grooming(uint32 _summoner) external {
        //Murasaki_Main mm = Murasaki_Main(murasaki_main_address);
        //Murasaki_Strage ms = Murasaki_Strage(murasaki_strage_address);
        require(mm.ownerOf(_summoner) == msg.sender);
        uint32 _now = uint32(block.timestamp);
        uint32 _exp = ms.exp(_summoner);
        uint32 _happy = calc_grooming(_summoner);
        _exp += 6000 * (100 - _happy) / 100;
        ms.set_exp(_summoner, _exp);
        ms.set_last_grooming_time(_summoner, _now);
    }
    function calc_grooming(uint32 _summoner) public view returns (uint32) {
        //Murasaki_Strage ms = Murasaki_Strage(murasaki_strage_address);
        uint32 _now = uint32(block.timestamp);
        uint32 _delta_sec = _now - ms.last_grooming_time(_summoner);
        uint32 _base = BASE_SEC *3 /SPEED;
        uint32 _happy;
        if (_delta_sec >= _base) {
            _happy = 0;
        }else {
            _happy = 100 * (_base - _delta_sec) / _base;
        }
        return _happy;
    }

    //mining
    function start_mining(uint32 _summoner) external {
        //Murasaki_Main mm = Murasaki_Main(murasaki_main_address);
        //Murasaki_Strage ms = Murasaki_Strage(murasaki_strage_address);
        require(mm.ownerOf(_summoner) == msg.sender);
        require(ms.mining_status(_summoner) == 0 && ms.farming_status(_summoner) == 0 && ms.crafting_status(_summoner) == 0);
        require(calc_feeding(_summoner) >= 20 && calc_grooming(_summoner) >= 20);
        //require(ms.level(_summoner) >= 2);
        uint32 _now = uint32(block.timestamp);
        ms.set_mining_status(_summoner, 1);
        ms.set_mining_start_time(_summoner, _now);
    }
    function stop_mining(uint32 _summoner) external {
        //Murasaki_Main mm = Murasaki_Main(murasaki_main_address);
        //Murasaki_Strage ms = Murasaki_Strage(murasaki_strage_address);
        require(mm.ownerOf(_summoner) == msg.sender);
        require(ms.mining_status(_summoner) == 1);
        uint32 _now = uint32(block.timestamp);
        uint32 _delta = calc_mining(_summoner);
        //luck modification
        if (d100(_summoner) <= ms.luck(_summoner)/100) {
            _delta = _delta *2;
        }
        //add coin
        uint32 _coin = ms.coin(_summoner) + _delta;
        ms.set_coin(_summoner, _coin);
        //update timestamp
        uint32 _delta_sec = _now - ms.mining_start_time(_summoner);
        uint32 _total_mining_sec = ms.total_mining_sec(_summoner) + _delta_sec;
        ms.set_total_mining_sec(_summoner, _total_mining_sec);
        uint32 _last_total_mining_sec = ms.last_total_mining_sec(_summoner) + _delta_sec;
        ms.set_last_total_mining_sec(_summoner, _last_total_mining_sec);
        uint32 _last_grooming_time_plus_working_time = ms.last_grooming_time_plus_working_time(_summoner) + _delta_sec;
        ms.set_last_grooming_time_plus_working_time(_summoner, _last_grooming_time_plus_working_time);
        ms.set_mining_status(_summoner, 0);
    }
    function calc_mining(uint32 _summoner) public view returns (uint32) {
        //Murasaki_Strage ms = Murasaki_Strage(murasaki_strage_address);
        require(ms.mining_status(_summoner) == 1);
        uint32 _now = uint32(block.timestamp);
        uint32 _delta = (_now - ms.mining_start_time(_summoner)) * SPEED / 100;
        _delta += ( _delta * ms.strength(_summoner) / 100 ) / 100;
        _delta += ( _delta * ms.level(_summoner) ) / 100;
        return _delta;
    }

    //farming
    function start_farming(uint32 _summoner) external {
        //Murasaki_Main mm = Murasaki_Main(murasaki_main_address);
        //Murasaki_Strage ms = Murasaki_Strage(murasaki_strage_address);
        require(mm.ownerOf(_summoner) == msg.sender);
        require(ms.mining_status(_summoner) == 0 && ms.farming_status(_summoner) == 0 && ms.crafting_status(_summoner) == 0);
        require(calc_feeding(_summoner) >= 20 && calc_grooming(_summoner) >= 20);
        //require(ms.level(_summoner) >= 2);
        uint32 _now = uint32(block.timestamp);
        ms.set_farming_status(_summoner, 1);
        ms.set_farming_start_time(_summoner, _now);
    }
    function stop_farming(uint32 _summoner) external {
        //Murasaki_Main mm = Murasaki_Main(murasaki_main_address);
        //Murasaki_Strage ms = Murasaki_Strage(murasaki_strage_address);
        require(mm.ownerOf(_summoner) == msg.sender);
        require(ms.farming_status(_summoner) == 1);
        uint32 _now = uint32(block.timestamp);
        uint32 _delta = calc_farming(_summoner);
        //luck modification
        if (d100(_summoner) <= ms.luck(_summoner)/100) {
            _delta = _delta *2;
        }
        //add coin
        uint32 _material = ms.material(_summoner) + _delta;
        ms.set_material(_summoner, _material);
        //update timestamp
        uint32 _delta_sec = _now - ms.farming_start_time(_summoner);
        uint32 _total_farming_sec = ms.total_farming_sec(_summoner) + _delta_sec;
        ms.set_total_farming_sec(_summoner, _total_farming_sec);
        uint32 _last_total_farming_sec = ms.last_total_farming_sec(_summoner) + _delta_sec;
        ms.set_last_total_farming_sec(_summoner, _last_total_farming_sec);
        uint32 _last_grooming_time_plus_working_time = ms.last_grooming_time_plus_working_time(_summoner) + _delta_sec;
        ms.set_last_grooming_time_plus_working_time(_summoner, _last_grooming_time_plus_working_time);
        ms.set_farming_status(_summoner, 0);
    }
    function calc_farming(uint32 _summoner) public view returns (uint32) {
        //Murasaki_Strage ms = Murasaki_Strage(murasaki_strage_address);
        require(ms.farming_status(_summoner) == 1);
        uint32 _now = uint32(block.timestamp);
        uint32 _delta = (_now - ms.farming_start_time(_summoner)) * SPEED / 100;
        _delta += ( _delta * ms.dexterity(_summoner) / 100 ) / 1000;
        _delta += ( _delta * ms.level(_summoner) ) / 1000;
        return _delta;
    }

    //level-up
    function level_up(uint32 _summoner) external {
        //Murasaki_Main mm = Murasaki_Main(murasaki_main_address);
        //Murasaki_Strage ms = Murasaki_Strage(murasaki_strage_address);
        require(mm.ownerOf(_summoner) == msg.sender);
        require(ms.mining_status(_summoner) == 0 && ms.farming_status(_summoner) == 0 && ms.crafting_status(_summoner) == 0);
        require(ms.exp(_summoner) >= ms.next_exp_required(_summoner));
        uint32 _now = uint32(block.timestamp);
        //calculate working percent
        uint32 _base_sec = _now - ms.last_level_up_time(_summoner);
        uint32 _resting_sec = _base_sec - ms.last_total_mining_sec(_summoner) - ms.last_total_farming_sec(_summoner) - ms.last_total_crafting_sec(_summoner);
        uint32 _percent_mining = 200 * (ms.last_total_mining_sec(_summoner) + _resting_sec/4) / _base_sec;
        uint32 _percent_farming = 200 * (ms.last_total_farming_sec(_summoner) + _resting_sec/4) / _base_sec;
        uint32 _percent_crafting = 200 * (ms.last_total_crafting_sec(_summoner) + _resting_sec/4) / _base_sec;
        uint32 _percent_resting = 200 * (_resting_sec/4) / _base_sec;
        //status addition
        ms.set_strength(_summoner, ms.strength(_summoner) + _percent_mining);
        ms.set_dexterity(_summoner, ms.dexterity(_summoner) + _percent_farming);
        ms.set_intelligence(_summoner, ms.intelligence(_summoner) + _percent_crafting);
        ms.set_luck(_summoner, ms.luck(_summoner) + _percent_resting);
        //update timestamp
        ms.set_last_total_mining_sec(_summoner, 0);
        ms.set_last_total_farming_sec(_summoner, 0);
        ms.set_last_total_crafting_sec(_summoner, 0);
        //reset feeding, grooming, and exp
        ms.set_last_feeding_time(_summoner, _now);
        ms.set_last_grooming_time(_summoner, _now);
        ms.set_exp(_summoner, 0);
        //level-up
        uint32 _next_level = ms.level(_summoner) + 1;
        ms.set_level(_summoner, _next_level);
        ms.set_last_level_up_time(_summoner, _now);
        //update next_exp_required
        if (_next_level == 2) {
            ms.set_next_exp_required(_summoner, 3000);
        }else if (_next_level == 3) {
            ms.set_next_exp_required(_summoner, 6000);
        }else if (_next_level == 4) {
            ms.set_next_exp_required(_summoner, 10000);
        }else if (_next_level == 5) {
            ms.set_next_exp_required(_summoner, 15000);
        }else if (_next_level == 6) {
            ms.set_next_exp_required(_summoner, 21000);
        }else if (_next_level == 7) {
            ms.set_next_exp_required(_summoner, 28000);
        }else if (_next_level == 8) {
            ms.set_next_exp_required(_summoner, 36000);
        }else if (_next_level == 9) {
            ms.set_next_exp_required(_summoner, 45000);
        }else if (_next_level == 10) {
            ms.set_next_exp_required(_summoner, 55000);
        }else if (_next_level == 11) {
            ms.set_next_exp_required(_summoner, 66000);
        }else if (_next_level == 12) {
            ms.set_next_exp_required(_summoner, 78000);
        }else if (_next_level == 13) {
            ms.set_next_exp_required(_summoner, 91000);
        }else if (_next_level == 14) {
            ms.set_next_exp_required(_summoner, 105000);
        }else if (_next_level == 15) {
            ms.set_next_exp_required(_summoner, 120000);
        }else if (_next_level == 16) {
            ms.set_next_exp_required(_summoner, 136000);
        }else if (_next_level == 17) {
            ms.set_next_exp_required(_summoner, 153000);
        }else if (_next_level == 18) {
            ms.set_next_exp_required(_summoner, 171000);
        }else if (_next_level == 19) {
            ms.set_next_exp_required(_summoner, 190000);
        }
    }

    /*
    //crafting
    function start_crafting(uint32 _summoner) public {
    }
    function stop_crafting(uint32 _summoner) public {
    }
    function calc_crafting(uint32 _summoner) public view returns (uint32) {
    }
    */

    //dice codex
    /* #********#
    function d100(uint _summoner) internal view returns (uint) {
        return dn(_summoner, 100);
    }
    */
    function d100(uint _summoner) internal pure returns (uint) {
        return _summoner * 0 + 10;
    }    
    function d20(uint _summoner) internal view returns (uint) {
        return dn(_summoner, 20);
    }
    function d12(uint _summoner) internal view returns (uint) {
        return dn(_summoner, 12);
    }    
    function d10(uint _summoner) internal view returns (uint) {
        return dn(_summoner, 10);
    }    
    function d8(uint _summoner) internal view returns (uint) {
        return dn(_summoner, 8);
    }    
    function d6(uint _summoner) internal view returns (uint) {
        return dn(_summoner, 6);
    }    
    function d4(uint _summoner) internal view returns (uint) {
        return dn(_summoner, 4);
    }    
    function dn(uint _summoner, uint _number) public view returns (uint) {
        return _seed(_summoner) % _number;
    }    
    function _random(string memory input) internal pure returns (uint256) {
        return uint256(keccak256(abi.encodePacked(input)));
    }    
    function _seed(uint _summoner) internal view returns (uint rand) {
        rand = _random(
            string(
                abi.encodePacked(
                    block.timestamp,
                    blockhash(block.number - 1),
                    _summoner,
                    msg.sender
                )
            )
        );
    }
}


