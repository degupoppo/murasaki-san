


<!---


picture
    背景
ok! クリックアイコン（grooming, mining, farming, crafting）
    クリックアイコン（crafting）
ok! しゅっきん！（お仕事へ移動中）
    ごきげん！（お腹いっぱい＆ハッピーなときなど）
    おなかへった・・・
    ものづくりちゅう！（クラフト中）
    ありがとう！（ご飯たべたあとなど）
    クラフトアイテムたくさん（飼い主手伝う）
    成功したよー！（クラフト成功時, mining終了時など）
    失敗しちゃった・・・（クラフト失敗時など）
    れべるあっぷ！


ToDo

    petのUI実装
        pet所持の有無を監視
        petの絵の用意
        pet関数の実装
            moving
            resting
            mining
            farming
            moving_working
        petへのstart mining/farmingとstopの実装

    craftingのUI実装
        item_idの選択方法
        craftのstart/stopボタン
        成功/失敗の表現

    summoner所持item
        所持itemの検索
        所持itemのスプライト表示

    資源のバランスと差別化
        coinとmaterialの差別化


Idea
    main idea
        献身によって成長と変化を実感できる育成型NFT
        時間が基本資源, summonerをどの状態にどれだけしたかで変化の仕方が違う
        マメにかつ長期間お世話されたsummonerほど出来ることが増える設計
        競争ではなく箱庭型、効率化を考えなくても良い雰囲気で。
        拡大再生産による可能性の拡大, 明日のコインのため今日コインを使う
        効率的にプレイしておおよそ2年間で最大値に達するインフレ率で。
            インフレ率を低くして、変化の少ない状態で長く遊べるようにする
            インフレ率：+100%/y程度を目指す
            mining特化して, 1年間の献身で+100%, farmingも同様
        全てのアイテムを買うことはできない。
    まとめ
        time
            1day=86,400secをmining, farming, crafting, restingのどれかに振り分ける
            mining: +coin, Lv-up時 +STR
            farming: +material, Lv-up時 +DEX
            crafting: item try, Lv-up時 +INT
            resting: grooming時 追加+EXP, 全部ステータス均等に追加
        Lv-up
            1レベル上がると全効率が+5%
            1年間で12-15Lvまで上がる, +60%-75%
            mining, farmingはLv2から, craftingはLv3から
            ステータスポイントは+1, 費やした時間に応じて分割して加算する
            設計と計算を用意しにするため、Level-up時にsatiety, happy, expをすべてリセットする
        item
            mining, farming, craftingに対応する3種類
                1つ所持すると効率+5%
            本体の半分の効率でmining, farmingするペット
            ステータスを恒久的に上昇させる木の実（非NFT）
            完全なオブジェ
            補正なしで3日で成功率80%程度の難易度
            難易度による差別化をどうするか
                すべて同じ効果だが, 効果を重複するために複数並べるには高いものも買わないといけない

--->



<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8" />
    <link rel="icon" type="png" href="png/icon.PNG">
    <title>House of Murasaki-San</title>
    <script src="phaser.js"></script>
    <script src="web3.min.js"></script>
    <script src="murasaki_main.js"></script>
    <script src="murasaki_craft.js"></script>
    <script src="murasaki_pet.js"></script>
    <style type="text/css">
        body {
            margin: 0;
        }
    </style>
</head>

<body>



<script type="text/javascript">



// global variants
//--------------------------------------------------------------------------------------------------------

const version = "0.0.14";
let turn = 0;

let local_ctype;
let local_strength;
let local_dexterity;
//let local_vitality;
let local_intelligence;
let local_luck;
let local_birth_time;
let local_level = 1;
let local_last_feeding_time;
let local_last_grooming_time;
let local_coin;
let local_exp;
let local_mining_status;
let local_mining_start_time;
let local_next_exp_required;
let local_material;
let local_farming_status;
let local_farming_start_time;
let local_crafting_status;
let local_crafting_start_time;
let previous_local_last_feeding_time;
let previous_local_last_grooming_time;
let previous_local_level;
let summoner = -1;
let satiety;
let happy;
let local_coin_calc;
let local_material_calc;
let local_crafting_calc;
let local_pet;
let local_pet_mining_status;
let local_pet_mining_start_time;
let local_pet_coin_calc;
let local_pet_farming_status;
let local_pet_farming_start_time;
let local_pet_material_calc;



// html
//--------------------------------------------------------------------------------------------------------

//get summoner from url parameter
//https://www.tam-tam.co.jp/tipsnote/javascript/post9911.html
var urlParam = location.search.substring(1);
if(urlParam) {
    var param = urlParam.split('&');
    var paramArray = [];
    for (i = 0; i < param.length; i++) {
        var paramItem = param[i].split('=');
        paramArray[paramItem[0]] = paramItem[1];
    }
    summoner = paramArray.summoner
}



// web3
//--------------------------------------------------------------------------------------------------------

//connect to metamask
async function connect() {
    const web3 = await new Web3(window.ethereum);
    window.ethereum.enable();
    window.ethereum.request({
        method: 'wallet_addEthereumChain',
        params: [{
            chainId: '0x51',  //4369
            chainName: 'Shibuya Testnet',
            nativeCurrency: {
                name: 'sby',
                symbol: 'SBY',
                decimals: 18
            },
            rpcUrls: ["https://rpc.shibuya.astar.network:8545"],
            blockExplorerUrls: ['https://blockscout.com/shibuya'],
        }]
    });
    return web3;
}

//get wallet
async function get_wallet(web3) {
    const wallet = await web3.eth.getAccounts();
    return wallet[0];
}

//prepare contract, need abi_contract.js
async function get_contract(web3) {
    const contract = await new web3.eth.Contract(abi_murasaki_main, contract_address_murasaki_main);
    return contract;
}

//prepare contract, pet
async function get_contract_pet(web3) {
    const contract = await new web3.eth.Contract(abi_murasaki_pet, contract_address_murasaki_pet);
    return contract;
}

//update local status reading from contract
async function contract_update_status(summoner) {
    let web3 = await connect();
    let contract = await get_contract(web3);
    let res = await contract.methods.get_status(summoner).call();
    console.log(res);   
    local_ctype = res[0];
    local_strength = res[1] /100;
    local_dexterity = res[2] /100;
    //local_vitality = res[3] /100;
    local_intelligence = res[4] /100;
    local_luck = res[5] /100;
    local_birth_time = res[6];
    local_last_feeding_time = res[7];
    local_last_grooming_time = res[8];
    local_coin = res[9];
    local_material = res[10];
    local_mining_status = res[11];
    local_mining_start_time = res[12];
    local_farming_status = res[13];
    local_farming_start_time = res[14];
    local_crafting_status = res[15];
    local_crafting_start_time = res[16];
    local_exp = res[17];
    local_level = res[18];
    local_next_exp_required = res[19];
    //progression status
    if (local_mining_status == 1){
        local_coin_calc = await contract.methods.calc_coin(summoner).call();
    }else if (local_farming_status == 1) {
        local_material_calc = await contract.methods.calc_material(summoner).call();
    }else if (local_crafting_status == 1) {
        local_crafting_calc = await contract.methods.calc_crafting(summoner).call();
    }
    //pet check
    //TODO: call whole items list, then view at type 49
    local_pet = await contract.methods.items(summoner, 49).call();
    if (local_pet != 0) {
        /* NEED to update contract!
        let contract_pet = await get_contract_pet(web3);
        res = await contract_pet.methods.get_status(summoner).call();
        local_pet_mining_status = res[0];
        local_pet_mining_start_time = res[1];
        local_pet_farming_status = res[2];
        local_pet_farming_start_time = res[3];
        */
    }
}

//send feeding
async function contract_feeding(summoner) {
    let web3 = await connect();
    let contract = await get_contract(web3);
    let wallet = await get_wallet(web3);
    contract.methods.feeding(summoner).send({from:wallet});
}

//send grooming
async function contract_grooming(summoner) {
    let web3 = await connect();
    let contract = await get_contract(web3);
    let wallet = await get_wallet(web3);
    contract.methods.grooming(summoner).send({from:wallet});
}

//send level_up
async function contract_level_up(summoner) {
    let web3 = await connect();
    let contract = await get_contract(web3);
    let wallet = await get_wallet(web3);
    contract.methods.level_up(summoner).send({from:wallet});
}

//summon
async function contract_summon(ctype) {
    let web3 = await connect();
    let contract = await get_contract(web3);
    let wallet = await get_wallet(web3);
    contract.methods.summon(ctype).send({from:wallet});
}

//mining
async function contract_start_mining(summoner) {
    let web3 = await connect();
    let contract = await get_contract(web3);
    let wallet = await get_wallet(web3);
    contract.methods.start_mining(summoner).send({from:wallet});
}
async function contract_stop_mining(summoner) {
    let web3 = await connect();
    let contract = await get_contract(web3);
    let wallet = await get_wallet(web3);
    contract.methods.stop_mining(summoner).send({from:wallet});
}

//farming
async function contract_start_farming(summoner) {
    let web3 = await connect();
    let contract = await get_contract(web3);
    let wallet = await get_wallet(web3);
    contract.methods.start_farming(summoner).send({from:wallet});
}
async function contract_stop_farming(summoner) {
    let web3 = await connect();
    let contract = await get_contract(web3);
    let wallet = await get_wallet(web3);
    contract.methods.stop_farming(summoner).send({from:wallet});
}

//crafting
async function contract_start_crafting(summoner) {
    let web3 = await connect();
    let contract = await get_contract(web3);
    let wallet = await get_wallet(web3);
    let item_type = 49;
    contract.methods.start_crafting(summoner, item_type).send({from:wallet});
}
async function contract_stop_crafting(summoner) {
    let web3 = await connect();
    let contract = await get_contract(web3);
    let wallet = await get_wallet(web3);
    contract.methods.stop_crafting(summoner).send({from:wallet});
}

//get items
async function contract_get_items(summoner) {
    let web3 = await connect();
    let contract = await get_contract(web3);
    let wallet = await get_wallet(web3);
    let items = await contract.methods.items(summoner,49).call();
    console.log(items);
}


// summoner
//--------------------------------------------------------------------------------------------------------
class Murasakisan extends Phaser.GameObjects.Sprite{
    constructor(scene, x, y){
        super(scene, x, y, "murasaki_right");
        this.scene.add.existing(this);
        this.anims.play("murasaki_right", true);
    	this.mode = "resting";
        this.submode = 0;
        this.count = 0;
        this.dist = "right";
        this.target_x = 0;
        this.target_y = 0;
        this.setInteractive()
        this.on("pointerdown", function (pointer) {
            this.on_click();
        }, this);
    }
    set set_mode(mode){
        this.mode = mode;
        this.count = 0;
    }
    get get_mode(){
        return this.mode;
    }
    on_click() {
        if (this.mode == "resting" || this.mode == "moving") {
            this.count = 0;
            this.mode = "hugging";
        }
    }
    resting(){
	    this.count += 1;
        if (this.count == 1) {
            if (this.dist == "right"){
                this.anims.play("murasaki_right", true);
            }else if (this.dist == "left") {
                this.anims.play("murasaki_left", true);
            }
            this.resting_count = 70 + Math.random() * 30;
	    }else if (this.count >= this.resting_count){
            let tmp = Math.random() * 100;
            if (tmp <= 10) {
                this.mode = "sleeping";
                this.count = 0;
            }else if (tmp <= 20 & happy <= 10) {
                this.mode = "crying";
                this.count = 0;
            }else {
                this.mode = "moving";
                this.count = 0;
            }
        }
    }
    moving() {
        this.count += 1;
        //determine direction
        if (this.count == 1){
            //determine degree, 0-30, 150-210, 330-360
            var li = [0,10,20,30,150,160,170,180,190,200,210,330,340,350]
            this.moving_degree = li[Math.floor(Math.random() * li.length)];
            //out of area check
            if (this.x < 100 && this.moving_degree > 90 && this.moving_degree <270) {
                this.moving_degree -= 180;
            }else if (this.x > 700 && (this.moving_degree < 90 || this.moving_degree > 270)) {
                this.moving_degree -= 180;
            }
            if (this.y > 500 && this.moving_degree > 180) {
                this.moving_degree = 360 - this.moving_degree;
            }else if (this.y < 300 && this.moving_degree < 180) {
                this.moving_degree = 360 - this.moving_degree;
            }
            //minus check
            if (this.moving_degree < 0) {
                this.moving_degree += 360;
            }
            //determine speed, count
            this.moving_speed = 0.3 + Math.random() * 0.2;  //0.3-0.5
            this.moving_count = 70 + Math.random() * 30;    //70-100
            //determine left or right
            if (this.moving_degree > 90 && this.moving_degree <= 270) {
                this.dist = "left";
                this.anims.play("murasaki_left", true);
            }else {
                this.dist = "right";
                this.anims.play("murasaki_right", true);
            }
            //debug
            //console.log(this.moving_degree, Math.sin(this.moving_degree * (Math.PI/180)), this.x, this.y);
        //moving
        }else if (this.count < this.moving_count) {
            this.x += Math.cos(this.moving_degree * (Math.PI/180)) * this.moving_speed;
            this.y -= Math.sin(this.moving_degree * (Math.PI/180)) * this.moving_speed;
        //return to resting
        }else if (this.count >= this.moving_count) {
            this.mode = "resting";
            this.count = 0;
        }
    }
    //send: last_nutrition_time
    feeding() {
        this.count += 1;
        if (this.submode == 0) {
            //this.target_x = 600;
            //this.target_y = 400;
            let delta_x = this.target_x - this.x;
            if (delta_x >0) {
                this.dist = "right";
                this.anims.play("murasaki_feeding_happy_right", true);
            }else {
                this.dist = "left";
                this.anims.play("murasaki_feeding_happy_left", true);
            }
            this.submode = 1;
        }else if (this.submode == 1) {
            let delta_x = this.target_x - this.x;
            let delta_y = this.target_y - this.y;
            let delta_x2 = delta_x / (Math.abs(delta_x) + Math.abs(delta_y)) * 1.2;
            let delta_y2 = delta_y / (Math.abs(delta_x) + Math.abs(delta_y)) * 1.2;
            this.x += delta_x2;
            this.y += delta_y2;
            if (this.x > this.target_x-10 
              && this.x < this.target_x+10 
              && this.y > this.target_y-10 
              && this.y < this.target_y+10) {
                this.submode = 2;
            }
        }else if (this.submode == 2) {
            this.anims.play("murasaki_feeding", true);
            food.destroy();
            this.count_limit = this.count + 1000;
            this.submode = 3;
        }else if (this.submode == 3) {
            if (this.count >= this.count_limit) {
                this.mode = "resting";
                this.count = 0;
            }
        }
    }
    crying() {
        this.count += 1;
        if (this.count == 1){
            this.anims.play("murasaki_crying", true);
        }else if (this.count >= 500) {
            this.mode = "resting";
            this.count = 0;
        }
    }
    sleeping() {
        this.count += 1;
        if (this.count == 1){
            this.anims.play("murasaki_sleeping", true);
        }else if (this.count >= 1000) {
            this.mode = "resting";
            this.count = 0;
        }
    }
    //send: last_grooming_time
    grooming() {
        this.count += 1;
        if (this.submode == 0) {
            let delta_x = this.target_x - this.x;
            if (delta_x >0) {
                this.dist = "right";
                this.anims.play("murasaki_feeding_happy_right", true);
            }else {
                this.dist = "left";
                this.anims.play("murasaki_feeding_happy_left", true);
            }
            this.submode = 1;
        }else if (this.submode == 1) {
            let delta_x = this.target_x - this.x;
            let delta_y = this.target_y - this.y;
            let delta_x2 = delta_x / (Math.abs(delta_x) + Math.abs(delta_y)) * 1.2;
            let delta_y2 = delta_y / (Math.abs(delta_x) + Math.abs(delta_y)) * 1.2;
            this.x += delta_x2;
            this.y += delta_y2;
            if (this.x > this.target_x-10 
              && this.x < this.target_x+10 
              && this.y > this.target_y-10 
              && this.y < this.target_y+10) {
                this.submode = 2;
            }
        }else if (this.submode == 2) {
            this.x = this.target_x;
            this.y = this.target_y;
            this.anims.play("murasaki_grooming", true);
            this.count_limit = this.count + 1500;
            this.submode = 3;
        }else if (this.submode == 3) {
            if (this.count >= this.count_limit) {
                this.mode = "resting";
                this.count = 0;
            }
        }
    }
    //cost: life, gain: coin
    mining() {
        this.count += 1;
        if (this.submode == 0) {
            let delta_x = this.target_x - this.x;
            if (delta_x >0) {
                this.dist = "right";
                this.anims.play("murasaki_working_right", true);
            }else {
                this.dist = "left";
                this.anims.play("murasaki_working_left", true);
            }
            this.submode = 1;
        }else if (this.submode == 1) {
            let delta_x = this.target_x - this.x;
            let delta_y = this.target_y - this.y;
            let delta_x2 = delta_x / (Math.abs(delta_x) + Math.abs(delta_y)) * 0.8;
            let delta_y2 = delta_y / (Math.abs(delta_x) + Math.abs(delta_y)) * 0.8;
            this.x += delta_x2;
            this.y += delta_y2;
            if (this.x > this.target_x-10 
              && this.x < this.target_x+10 
              && this.y > this.target_y-10 
              && this.y < this.target_y+10) {
                this.submode = 2;
            }
        }else if (this.submode == 2) {
            this.anims.play("murasaki_mining", true);
        }
    }
    hugging() {
        this.count += 1;
        if (this.count == 1){
            this.anims.play("murasaki_click", true);
        }else if (this.count >= 250) {
            this.mode = "resting";
            this.count = 0;
        }
    }
    farming() {
        this.count += 1;
        if (this.submode == 0) {
            let delta_x = this.target_x - this.x;
            if (delta_x >0) {
                this.dist = "right";
                this.anims.play("murasaki_working_right", true);
            }else {
                this.dist = "left";
                this.anims.play("murasaki_working_left", true);
            }
            this.submode = 1;
        }else if (this.submode == 1) {
            let delta_x = this.target_x - this.x;
            let delta_y = this.target_y - this.y;
            let delta_x2 = delta_x / (Math.abs(delta_x) + Math.abs(delta_y)) * 0.8;
            let delta_y2 = delta_y / (Math.abs(delta_x) + Math.abs(delta_y)) * 0.8;
            this.x += delta_x2;
            this.y += delta_y2;
            if (this.x > this.target_x-10 
              && this.x < this.target_x+10 
              && this.y > this.target_y-10 
              && this.y < this.target_y+10) {
                this.submode = 2;
            }
        }else if (this.submode == 2) {
            this.anims.play("murasaki_farming", true);
        }
    }
    crafting() {
        this.count += 1;
        if (this.submode == 0) {
            let delta_x = this.target_x - this.x;
            if (delta_x >0) {
                this.dist = "right";
                this.anims.play("murasaki_working_right", true);
            }else {
                this.dist = "left";
                this.anims.play("murasaki_working_left", true);
            }
            this.submode = 1;
        }else if (this.submode == 1) {
            let delta_x = this.target_x - this.x;
            let delta_y = this.target_y - this.y;
            let delta_x2 = delta_x / (Math.abs(delta_x) + Math.abs(delta_y)) * 0.8;
            let delta_y2 = delta_y / (Math.abs(delta_x) + Math.abs(delta_y)) * 0.8;
            this.x += delta_x2;
            this.y += delta_y2;
            if (this.x > this.target_x-10 
              && this.x < this.target_x+10 
              && this.y > this.target_y-10 
              && this.y < this.target_y+10) {
                this.submode = 2;
            }
        }else if (this.submode == 2) {
            this.anims.play("murasaki_farming", true);
        }
    }
    update(){
        //console.log(this.version, this.mode, this.count);
        if (this.mode == "resting") {this.resting();}
        else if (this.mode == "moving") {this.moving();}
        else if (this.mode == "feeding") {this.feeding();}
        else if (this.mode == "crying") {this.crying();}
        else if (this.mode == "sleeping") {this.sleeping();}
        else if (this.mode == "grooming") {this.grooming();}
        else if (this.mode == "mining") {this.mining();}
        else if (this.mode == "hugging") {this.hugging();}
        else if (this.mode == "farming") {this.farming();}
        else if (this.mode == "crafting") {this.farming();}
    }
}



//accessories
//--------------------------------------------------------------------------------------------------------

//bar
function makeBar(scene, x, y, color) {
    //draw the bar
    let bar = scene.add.graphics();
    //color the bar
    bar.fillStyle(color, 1);
    //fill the bar with a rectangle
    bar.fillRect(0, 0, 100, 10);
    //position the bar
    bar.x = x;
    bar.y = y;
    //return the bar
    return bar;
}


//button
//TODO: send transaction
class Button {
    constructor(x, y, label, scene, callback) {
        let fontsize = 18;
        const button = scene.add.text(x, y, label)
            .setFontSize(fontsize)
            .setFontFamily("Arial")
            .setFill("#000000")
            //.setOrigin(0.5)
            //.setPadding(10)
            //.setStyle({ backgroundColor: '#111' })
            .setInteractive({ useHandCursor: true })
            .on('pointerdown', () => callback())
            .on('pointerover', () => button.setStyle({ fontSize: fontsize, fontFamily: "Arial", fill: '#ffff00' }))
            .on('pointerout', () => button.setStyle({ fontSize: fontsize, fontFamily: "Arial", fill: '#000000' }));
    }
}



// main functions
//--------------------------------------------------------------------------------------------------------


let config = {
    type: Phaser.AUTO,
    width: 800,
    height: 600,
    scale: {
        mode: Phaser.Scale.FIT,
        autoCenter: Phaser.Scale.CENTER_BOTH
    },
    scene: {
        preload: preload,
        create: create,
        update: update
    },
    render: {
        pixelArt: false
    },
};
let game = new Phaser.Game(config);



// preload
//--------------------------------------------------------------------------------------------------------
function preload() {
    this.load.image("back", "png/back.jpg");
    this.load.spritesheet("murasaki_right", "png/murasaki_right.png", {frameWidth: 370, frameHeight: 320});
    this.load.spritesheet("murasaki_left", "png/murasaki_left.png", {frameWidth: 370, frameHeight: 320});
    this.load.spritesheet("murasaki_sleeping", "png/murasaki_sleeping.png", {frameWidth: 370, frameHeight: 320});
    this.load.spritesheet("murasaki_feeding", "png/murasaki_feeding.png", {frameWidth: 370, frameHeight: 320});
    this.load.spritesheet("murasaki_feeding_happy_right", 
        "png/murasaki_feeding_happy_right.png", {frameWidth: 370, frameHeight: 320});
    this.load.spritesheet("murasaki_feeding_happy_left", 
        "png/murasaki_feeding_happy_left.png", {frameWidth: 370, frameHeight: 320});
    this.load.spritesheet("murasaki_crying", "png/murasaki_crying.png", {frameWidth: 370, frameHeight: 320});
    this.load.spritesheet("murasaki_mining", "png/murasaki_mining.png", {frameWidth: 370, frameHeight: 320});
    this.load.spritesheet("murasaki_hugging", "png/murasaki_hugging.png", {frameWidth: 370, frameHeight: 320});
    this.load.spritesheet("murasaki_farming", "png/murasaki_farming.png", {frameWidth: 370, frameHeight: 320});
    this.load.spritesheet("murasaki_grooming", "png/murasaki_grooming.png", {frameWidth: 720, frameHeight: 622});
    this.load.spritesheet("murasaki_working_left", "png/murasaki_working_left.png", {frameWidth: 370, frameHeight: 320});
    this.load.spritesheet("murasaki_working_right", "png/murasaki_working_right.png", {frameWidth: 370, frameHeight: 320});
    this.load.spritesheet("murasaki_click", "png/murasaki_click.png", {frameWidth: 370, frameHeight: 320});
    this.load.image("button_feeding", "png/button_feeding.png", {frameWidth: 500, frameHeight: 500});
    this.load.image("button_grooming", "png/button_grooming.png", {frameWidth: 500, frameHeight: 500});
    this.load.image("button_mining", "png/button_mining.png", {frameWidth: 500, frameHeight: 500});
    this.load.image("button_farming", "png/button_farming.png", {frameWidth: 500, frameHeight: 500});
    this.load.image("food_sweet_potato", "png/food_sweet_potato.png", {frameWidth: 500, frameHeight: 500});
    this.load.image("item_bear", "png/item_bear.png", {frameWidth: 720, frameHeight: 622});
    //cursors = this.input.keyboard.createCursorKeys();
}



// create
//--------------------------------------------------------------------------------------------------------
function create() {

    //back image
    this.add.image(400, 300, "back");

    //animations
    this.anims.create({
        key: "murasaki_right",
        frames: this.anims.generateFrameNumbers("murasaki_right", {start: 0, end:3}),
        frameRate: 2,
        repeat: -1
    });
    this.anims.create({
        key: "murasaki_left",
        frames: this.anims.generateFrameNumbers("murasaki_left", {start: 0, end:3}),
        frameRate: 2,
        repeat: -1
    });
    this.anims.create({
        key: "murasaki_sleeping",
        frames: this.anims.generateFrameNumbers("murasaki_sleeping", {start: 0, end:1}),
        frameRate: 1,
        repeat: -1
    });
    this.anims.create({
        key: "murasaki_feeding",
        frames: this.anims.generateFrameNumbers("murasaki_feeding", {start: 0, end:1}),
        frameRate: 1,
        repeat: -1
    });
    this.anims.create({
        key: "murasaki_feeding_happy_right",
        frames: this.anims.generateFrameNumbers("murasaki_feeding_happy_right", {start: 0, end:1}),
        frameRate: 1,
        repeat: -1
    });
    this.anims.create({
        key: "murasaki_feeding_happy_left",
        frames: this.anims.generateFrameNumbers("murasaki_feeding_happy_left", {start: 0, end:1}),
        frameRate: 1,
        repeat: -1
    });
    this.anims.create({
        key: "murasaki_crying",
        frames: this.anims.generateFrameNumbers("murasaki_crying", {start: 0, end:1}),
        frameRate: 1,
        repeat: -1
    });
    this.anims.create({
        key: "murasaki_mining",
        frames: this.anims.generateFrameNumbers("murasaki_mining", {start: 0, end:1}),
        frameRate: 1,
        repeat: -1
    });
    this.anims.create({
        key: "murasaki_hugging",
        frames: this.anims.generateFrameNumbers("murasaki_hugging", {start: 0, end:1}),
        frameRate: 1,
        repeat: -1
    });
    this.anims.create({
        key: "murasaki_farming",
        frames: this.anims.generateFrameNumbers("murasaki_farming", {start: 0, end:1}),
        frameRate: 1,
        repeat: -1
    });
    this.anims.create({
        key: "murasaki_grooming",
        frames: this.anims.generateFrameNumbers("murasaki_grooming", {start: 0, end:1}),
        frameRate: 1,
        repeat: -1
    });
    this.anims.create({
        key: "murasaki_working_left",
        frames: this.anims.generateFrameNumbers("murasaki_working_left", {start: 0, end:1}),
        frameRate: 1,
        repeat: -1
    });
    this.anims.create({
        key: "murasaki_working_right",
        frames: this.anims.generateFrameNumbers("murasaki_working_right", {start: 0, end:1}),
        frameRate: 1,
        repeat: -1
    });
    this.anims.create({
        key: "murasaki_click",
        frames: this.anims.generateFrameNumbers("murasaki_click", {start: 0, end:1}),
        frameRate: 1,
        repeat: -1
    });

    //items
    //bear
    item_bear = this.add.sprite(300,250, "item_bear");
    item_bear.scaleX = item_bear.scaleX * 0.25;
    item_bear.scaleY = item_bear.scaleY * 0.25;

    //button_icon
    button_feeding = this.add.sprite(680,400, "button_feeding");
    button_feeding.scaleX = button_feeding.scaleX * 0.1;
    button_feeding.scaleY = button_feeding.scaleY * 0.1;
    button_feeding.setInteractive({useHandCursor: true});
    button_feeding.on('pointerdown', () => contract_feeding(summoner) );
    button_grooming = this.add.sprite(350,150, "button_grooming");
    button_grooming.scaleX = button_grooming.scaleX * 0.1;
    button_grooming.scaleY = button_grooming.scaleY * 0.1;
    button_grooming.setInteractive({useHandCursor: true});
    button_grooming.on('pointerdown', () => contract_grooming(summoner) );
    button_mining = this.add.sprite(40,390, "button_mining");
    button_mining.scaleX = button_mining.scaleX * 0.1;
    button_mining.scaleY = button_mining.scaleY * 0.1;
    button_mining.setInteractive({useHandCursor: true});
    button_mining.on('pointerdown', () => contract_start_mining(summoner) );
    button_farming = this.add.sprite(40,220, "button_farming");
    button_farming.scaleX = button_farming.scaleX * 0.1;
    button_farming.scaleY = button_farming.scaleY * 0.1;
    button_farming.setInteractive({useHandCursor: true});
    button_farming.on('pointerdown', () => contract_start_farming(summoner) );
    button_crafting = this.add.sprite(500,150, "button_feeding");
    button_crafting.scaleX = button_crafting.scaleX * 0.1;
    button_crafting.scaleY = button_crafting.scaleY * 0.1;
    button_crafting.setInteractive({useHandCursor: true});
    button_crafting.on('pointerdown', () => contract_start_crafting(summoner) );

    //summoner
    murasakisan = new Murasakisan(this, 300 + Math.random()*200, 400 + Math.random()*100);
    murasakisan.scaleX = murasakisan.scaleX * 0.25;
    murasakisan.scaleY = murasakisan.scaleY * 0.25;

    //button_text
    new Button(30, 10, 'Level Up', this, () => contract_level_up(summoner));
    new Button(30, 40, 'Stop Mining', this, () => contract_stop_mining(summoner));
    new Button(30, 70, 'Stop Farming', this, () => contract_stop_farming(summoner));
    new Button(30, 100, 'Stop Crafting', this, () => contract_stop_crafting(summoner));
    new Button(30, 130, 'Test', this, () => contract_get_items(summoner));

    //new Button(30, 40, 'Feeding', this, () => contract_feeding(summoner));
    //new Button(30, 70, 'Grooming', this, () => contract_grooming(summoner));
    //new Button(30, 100, 'Start Mining', this, () => contract_start_mining(summoner));
    //new Button(30, 160, 'Start Farming', this, () => contract_start_farming(summoner));
    //new Button(30, 250, 'Summon', this, () => contract_summon("1"));
    //new Button(30, 280, 'Test', this, () => update_summoner_list());

    //status window color fill
    let status_back = this.add.graphics();
    status_back.fillStyle(0xa9a9a9, 1).fillRect(590, 5, 200, 300);
    status_back.alpha = 0.4;

    //status window
    let font_arg = {font: "10.5px Arial", fill: "#000"};
    text_summoner =     this.add.text(600,  10, "Summoner: " + summoner, font_arg);
    text_type =         this.add.text(600,  20, "Type: " + local_ctype, font_arg);
    text_level =        this.add.text(600,  40, "  Lv: " + local_level, font_arg);
    text_strength =     this.add.text(600,  50, " STR: " + local_strength, font_arg);
    text_dexterity =    this.add.text(600,  60, " DEX: " + local_dexterity, font_arg);
    text_intelligence = this.add.text(600,  70, " INT = " + local_intelligence, font_arg);
    text_luck =         this.add.text(600,  80, " LUK: " + local_luck, font_arg);
    text_exp =          this.add.text(600, 100, " EXP: " + local_exp, font_arg);
    text_turn =         this.add.text(600, 120, "turn = ", font_arg);
    text_age_time =     this.add.text(600, 130, " age = ", font_arg);
    text_mode =         this.add.text(600, 140, "mode = ", font_arg);
    //text_vitality =     this.add.text(600,  70, " VIT: " + local_vitality, font_arg);
    //text_version = this.add.text(600, 10, "version = " + version, {font: "10.5px Arial", fill: "#000"});
    //text_last_feeding_time = this.add.text(
    //    600, 130, "last_feeding_time = " + local_last_feeding_time, {font: "10.5px Arial", fill: "#000"});
    //text_last_grooming_time = this.add.text(
    //    600, 140, "last_grooming_time = " + local_last_grooming_time, {font: "10.5px Arial", fill: "#000"});
    //text_coin = this.add.text(
    //    600, 150, "coin = " + local_coin, {font: "10.5px Arial", fill: "#000"});
    //text_birth_time = this.add.text(
    //    600, 50, "birth_time = " + local_birth_time, {font: "10.5px Arial", fill: "#000"});
    //text_satiety = this.add.text(
    //    600, 230, "satiey = ", {font: "10.5px Arial", fill: "#000"});
    //text_happy = this.add.text(
    //    600, 240, "happy = ", {font: "10.5px Arial", fill: "#000"});

    //bar
    //satiety
    this.add.text(600, 160, "Satiety:", font_arg);
    bar_satiety_back = makeBar(this, 640, 160, 0xa9a9a9);
    bar_satiety_back.scaleX = 1;
    bar_satiety = makeBar(this, 640, 160, 0xff4500);
    bar_satiety.scaleX = 0;
    //happy
    this.add.text(600, 180, "Happy:", font_arg);
    bar_happy_back = makeBar(this, 640, 180, 0xa9a9a9);
    bar_happy_back.scaleX = 1;
    bar_happy = makeBar(this, 640, 180, 0x4169e1);
    bar_happy.scaleX = 0;
    //exp
    this.add.text(600, 200, "EXP:", font_arg);
    bar_exp_back = makeBar(this, 640, 200, 0xa9a9a9);
    bar_exp_back.scaleX = 1;
    bar_exp = makeBar(this, 640, 200, 0x228b22);
    bar_exp.scaleX = 0;
    //coin
    text_coin = this.add.text(
        600, 220, "Coin: " + local_coin, font_arg);
    text_material = this.add.text(
        600, 230, "Material: " + local_material, font_arg);

    //progression
    text_working_mode = this.add.text(600, 250, "***", font_arg);
    text_working_calc = this.add.text(600, 260, "***", font_arg);

    //pet
    text_pet = this.add.text(600, 280, "***", font_arg);

}



// update
//--------------------------------------------------------------------------------------------------------
function update() {

    if (summoner == -1) {
        return 0;
    }

    //increment turn
    turn += 1;
    //text_turn.setText("turn = " + turn);

    //update character
    murasakisan.update();

    //update calculation status
    if (turn % 100 == 0) {

        //level up
        if (local_level > previous_local_level) {
        }else 

        //feeding check
        if (local_last_feeding_time > previous_local_last_feeding_time){
            murasakisan.set_mode = "feeding";
            murasakisan.submode = 0;
            murasakisan.count = 0;
            murasakisan.target_x = 600;
            murasakisan.target_y = 400;
            if (typeof food !== "undefined") {
                food.destroy();
                //food.visible = false;
            }
            food = this.add.sprite(600,400, "food_sweet_potato");
            food.scaleX = food.scaleX * 0.1;
            food.scaleY = food.scaleY * 0.1;
        }else

        //grooming check
        if (local_last_grooming_time > previous_local_last_grooming_time){
            murasakisan.set_mode = "grooming";
            murasakisan.submode = 0;
            murasakisan.count = 0;
            murasakisan.target_x = 300;
            murasakisan.target_y = 250;
        }

        //mining check
        if (local_mining_status == 1 & murasakisan.mode != "mining" & murasakisan.mode != "feeding"){
            murasakisan.set_mode = "mining";
            murasakisan.submode = 0;
            murasakisan.count = 0;
            murasakisan.target_x = 70;
            murasakisan.target_y = 420;
        }else if (local_mining_status == 0 & murasakisan.mode == "mining") {
            murasakisan.set_mode = "resting";
        }else

        //farming check
        if (local_farming_status == 1 & murasakisan.mode != "farming" & murasakisan.mode != "feeding"){
            murasakisan.set_mode = "farming";
            murasakisan.submode = 0;
            murasakisan.count = 0;
            murasakisan.target_x = 150;
            murasakisan.target_y = 260;
        }else if (local_farming_status == 0 & murasakisan.mode == "farming") {
            murasakisan.set_mode = "resting";
        }else 

        //crafting check
        if (local_crafting_status == 1 & murasakisan.mode != "crafting" & murasakisan.mode != "feeding"){
            murasakisan.set_mode = "crafting";
            murasakisan.submode = 0;
            murasakisan.count = 0;
            murasakisan.target_x = 500;
            murasakisan.target_y = 250;
        }else if (local_crafting_status == 0 & murasakisan.mode == "crafting") {
            murasakisan.set_mode = "resting";
        }

        //update calculation_status
        let now_time = Date.now() / 1000;
        let age_time = Math.round(now_time - local_birth_time);
        let mode = murasakisan.get_mode;
        let base = 86400 /10;
        //satiety
        satiety = Math.round( (base - (now_time - local_last_feeding_time)) / base * 100 );
        if (satiety < 0) { satiety = 0; }
        if (satiety > 100) { satiety = 100; }
        let base2 = 86400 * 3 /10;
        //happy
        happy = Math.round( (base2 - (now_time - local_last_grooming_time)) / base2 * 100 );
        if (happy < 0) { happy = 0; }
        if (happy > 100) { happy = 100; }
        //exp
        let exp = (local_exp / local_next_exp_required) * 100;
        if (exp > 100) { exp = 100; }

        //update text
        text_summoner.setText   ("summoner = " + summoner);
        text_type.setText       ("type = " + local_ctype);
        //status
        text_level.setText          (" Lv: " + local_level);
        text_strength.setText       ("STR: " + local_strength);
        text_dexterity.setText      ("DEX: " + local_dexterity);
        //text_vitality.setText       ("VIT: " + local_vitality);
        text_intelligence.setText   ("INT: " + local_intelligence);
        text_luck.setText           ("LUK: " + local_luck);
        text_exp.setText            ("EXP: " + local_exp);
        //game info
        text_turn.setText       ("turn = " + turn);
        text_age_time.setText   ("age = " + age_time);
        text_mode.setText       ("mode = " + mode);
        //coin & material
        text_coin.setText("coin = " + local_coin);
        text_material.setText("material = " + local_material);

        //update bar
        bar_satiety.scaleX = satiety / 100;
        bar_happy.scaleX = happy / 100;
        bar_exp.scaleX = exp / 100;

        //update progression status
        if (mode == "mining") {
            text_working_mode.setText("+coin");
            text_working_calc.setText(local_coin_calc);
        }else if (mode == "farming") {
            text_working_mode.setText("+material");
            text_working_calc.setText(local_material_calc);
        }else if (mode == "crafting") {
            text_working_mode.setText("complete crafting");
            text_working_calc.setText(local_crafting_calc + " sec");
        }else {
            text_working_mode.setText("*****");
            text_working_calc.setText("*****");
        }

        //pet
        if (local_pet == 0) {
            text_pet.setText("pet_id = not yet crafted");
        } else{
            text_pet.setText("pet_id = " + local_pet);
        }

        //text_birth_time.setText("birth_time = " + local_birth_time);
        //text_last_feeding_time.setText("last_feeding_time = " + local_last_feeding_time);
        //text_last_grooming_time.setText("last_grooming_time = " + local_last_grooming_time);
        //text_satiety.setText("satiety = " + satiety);
        //text_happy.setText("happy = " + happy);
        //text_coin_main.setText("coin:    " + local_coin);
        //text_material_main.setText("material:" + local_material);

        previous_local_last_feeding_time = local_last_feeding_time;
        previous_local_last_grooming_time = local_last_grooming_time;
        previous_local_level = local_level;
    }

    //update dynamic status from contract to local
    if (turn == 1 || turn % 201 == 0) {
        //update dynamic_status
        //summoner = document.getElementById("summoner").value;
        contract_update_status(summoner);
    }
}



</script>



</body>
</html>



<!---

//garbedge
//--------------------------------------------------------------------------------------------------------

    ok コントラクト内にステータスを保持する
    ok コントラクト内のステータスを読み出す
    ok ステータスを保有したNFTを作成する
    ok NFTのmint方法を確立する
    ok 場所への移動を実装する, mining, farming, feedingに組み込む, コードの汎用性を上げる
    ok 絵を大きめにする, 元絵を大きめに読み込み, scaleXYで縮小する
    ok Lvを実装する。必要expの対応表を作製する。
    ok 移動を見直す. 距離ランダム, 上下の動きも実装する
    ok つっつき動作の実装
    ok fake contractにfeeding(), grooming(), lv_up()を実装する
    ok ボタンの実装、表示、押したときの動作
    ok eating実装
    ok grooming実装
    ok コントラを見立てた外部ステータス格納区域の実装と、読み込み、書き込みの実装
    ok キャラのステータスをテキストで描写, コントラから定期的に取得し計算する
    ok ステータスはキャラクラスに保持させずに、コントラに見立てた外部変数に格納する。
    ok 1日1回？feeding, last_feeding_timeからの差でexp加算, 24hr以上の差は無効
    ok satiety, happy, expのバーを実装する

//dummy contract
//--------------------------------------------------------------------------------------------------------
class Contract {
    constructor() {
        //NFT parameters
        this.id = "001";
        this.type = Math.trunc(Math.random() * 5);
        this.strength = 2 + Math.trunc(Math.random() * 8);
        this.dexterity = 2 + Math.trunc(Math.random() * 8);
        this.vitality = 2 + Math.trunc(Math.random() * 8);
        this.intelligence = 2 + Math.trunc(Math.random() * 8);
        this.luck = 2 + Math.trunc(Math.random() * 8);
        this.birth_time = Date.now();
        this.last_feeding_time = Date.now();
        this.last_grooming_time = Date.now();
        this.coin = 100;
        this.material = 0;
        this.mining_status = 0;
        this.mining_start_time = 0;
        this.farming_status = 0;
        this.farming_start_time = 0;
        this.crafting_status = 0;
        this.crafting_start_time = 0;
        this.exp = 0;
        this.level = 1;
        this.next_exp_required = 1000;
        //contract parameters
        this.next_summoners = 0;
    }
    grooming() {
        let delta = (Date.now() - this.last_grooming_time) / 1000;
        this.last_grooming_time = Date.now();
        this.exp += delta;
    }
    feeding() {
        let delta = (Date.now() - this.last_feeding_time) / 1000;
        this.last_feeding_time = Date.now();
        this.exp += delta;
    }
    start_crafting(item_id) {
        if (this.mining_status == 0 && this.farming_status == 0 && this.crafting_status == 0){
            this.crafting_start_time = Date.now();
            this.crafting_status = 1;
        }
    }
    stop_crafting(item) {
        if (this.crafting_status == 1) {
            let delta = (Date.now() - this.crafting_start_time) / 1000;
            //nft mint check
            this.crafting_status = 0;
        }
    }
    start_mining() {
        if (this.mining_status == 0 && this.farming_status == 0 && this.crafting_status == 0){
        //if (this.mining_status == 0){
            this.mining_start_time = Date.now();
            this.mining_status = 1;
        }
    }
    stop_mining() {
        if (this.mining_status == 1) {
            let delta = (Date.now() - this.mining_start_time) / 10000;
            delta = Math.trunc(delta);
            this.coin += delta;
            this.mining_status = 0;
        }
    }
    start_farming() {
        if (this.mining_status == 0 && this.farming_status == 0 && this.crafting_status == 0){
            this.farming_start_time = Date.now();
            this.farming_status = 1;
        }
    }
    stop_farming() {
        if (this.farming_status == 1) {
            let delta = (Date.now() - this.farming_start_time) / 100000;
            delta = Math.trunc(delta);
            this.material += delta;
            this.farming_status = 0;
        }
    }
    level_up() {
        if (this.exp >= this.next_exp_required) {
            this.exp -= this.next_exp_required;
            this.level += 1;
            //status up
            var tmp = Math.trunc(Math.random() * 5);
            if (tmp == 0) {
                this.strength += 1;
            }else if (tmp == 1) {
                this.dexterity += 1;
            }else if (tmp == 2) {
                this.vitality += 1;
            }else if (tmp == 3) {
                this.intelligence += 1;
            }else {
                this.luck += 1;
            }
            //update next exp
            if (this.level == 2) {
                this.next_exp_required = 3000;
            }else if (this.level == 3) {
                this.next_exp_required = 6000;
            }else if (this.level == 4) {
                this.next_exp_required = 10000;
            }else if (this.level == 5) {
                this.next_exp_required = 15000;
            }else if (this.level == 6) {
                this.next_exp_required = 21000;
            }else if (this.level == 7) {
                this.next_exp_required = 28000;
            }else if (this.level == 8) {
                this.next_exp_required = 36000;
            }else if (this.level == 9) {
                this.next_exp_required = 45000;
            }else if (this.level == 10) {
                this.next_exp_required = 55000;
            }else if (this.level == 11) {
                this.next_exp_required = 66000;
            }else if (this.level == 12) {
                this.next_exp_required = 78000;
            }else if (this.level == 13) {
                this.next_exp_required = 91000;
            }else if (this.level == 14) {
                this.next_exp_required = 105000;
            }else if (this.level == 15) {
                this.next_exp_required = 120000;
            }else if (this.level == 16) {
                this.next_exp_required = 136000;
            }else if (this.level == 17) {
                this.next_exp_required = 153000;
            }else if (this.level == 18) {
                this.next_exp_required = 171000;
            }else if (this.level == 19) {
                this.next_exp_required = 190000;
            }
        }
    }
}

//call status from contract
async function test() {
    let web3 = await connect();
    let contract = await get_contract(web3);
    local_strength = await contract.methods.get_strength().call();
    local_dexterity = await contract.methods.get_dexterity().call();
    local_vitality = await contract.methods.get_vitality().call();
    local_intelligence = await contract.methods.get_intelligence().call();
    local_luck = await contract.methods.get_luck().call();
    local_birth_time = await contract.methods.get_birth_time().call();
    local_last_feeding_time = await contract.methods.get_last_feeding_time().call();
    local_last_grooming_time = await contract.methods.get_last_grooming_time().call();
    local_coin = await contract.methods.get_coin().call();
    local_material = await contract.methods.get_material().call();
    local_mining_status = await contract.methods.get_mining_status().call();
    local_mining_start_time = await contract.methods.get_mining_start_time().call();
    local_farming_status = await contract.methods.get_farming_status().call();
    local_farming_start_time = await contract.methods.get_farming_start_time().call();
    local_crafting_status = await contract.methods.get_crafting_status().call();
    local_crafting_start_time = await contract.methods.get_crafting_start_time().call();
    local_exp = await contract.methods.get_exp().call();
    local_level = await contract.methods.get_level().call();
    local_next_exp_required = await contract.methods.get_next_exp_required().call();
}

//get owned summoners
async function contract_my_summoners() {
    let web3 = await connect();
    let contract = await get_contract(web3);
    let wallet = await get_wallet(web3);
    let next_summoner = await contract.methods.next_summoner().call();
    let res = [];
    for (let i = 0; i < next_summoner; i++) {
        let owner = await contract.methods.ownerOf(i).call();
        if (owner == wallet) {
            res.push({text:i, value:i});
        }
    }
    console.log(res);
    return res;
}

//update summoner select list
function _create_dropdownlist( form_name, select_name, select_array ){
	document[form_name][select_name].length = select_array.length;
	var i;
	for ( i=0; i<select_array.length; i++){
		document[form_name][select_name].options[i].text = select_array[i].text;
		document[form_name][select_name].options[i].value = select_array[i].value;
	}
}
async function button_update_summoners() {
    opt_array = await contract_my_summoners();
    _create_dropdownlist("select_summoner","select_summoner", opt_array )
}

//update summoner
function button_select_summoner() {
    summoner = document.getElementById("summoner").value;
    previous_local_last_feeding_time = Date.now() + 10;
    previous_local_last_grooming_time = Date.now() + 10;
    murasakisan.set_mode = "resting";
}


    working()の概念を考える
        コインを稼ぐ
        str依存？動作とステータスのイメージが一致するように
        マイニング？お花摘み？
    クラフト, luck, str, dexなどのステータス＋クラフト時間で成功率を変える、アイテムごとに難易度が違う
        難しいものでも、１ヶ月とかクラフトし続ければ作れるかもしれない。
        連続思考を防ぐため、０％も作る。またファンブルで必ず５％は失敗する
        クラフト品のユースケースは？
    資産
        summoner間での移動は50%が消える
        exp?, 時間, コイン（sota?, ohana?), 素材(あまり種類を多くしない, 低級、中級、上級、ぐらい）
        exp
            お世話で取得
            Lv upで消費
        コイン
            miningで取得
            Craftingで消費
        素材
            farmingで取得
            Craftingで消費
    効率・補正
        Lv, Str/Dex/Intなどのステータス, endを押すまでの経過時間
        クラフト品による補正
    時間を資源に
        フリー時間しかgroomingなどできない
        working, やcraftingは時間を費やせばそれだけ効率や成功率が増大する
        しかしworkingさせているとgroomingやfeedingできずにexpがたまらない
    ステータス
        Lvアップで増加？ランダム？
        木の実をクラフトし使用する、確率を小さくするか、高価にする
        Strength: 筋力
            Miningの効率up
        Dexterity: 器用さ
            Farmingの効率up
        Intelligence: 知力
            Craftingの効率up
        Vitality: 体力
            不要？
        Luck: 運
            ボーナスダイスに加算
    お世話, expを得る
        feeding, デイリークエスト, コストなし, 24時間で最大効率
        grooming, プラスアルファ, 何かしらのコスト必要, 168時間で最大効率

ok  working中のfeeding動作の実装
ok  leve-up時のfeeding, grooming暴発対策
ok  Vit不要か
        restingはexpブースト, Lukをわずかに上昇？
ok  stopのUI実装
        mining: 現在の+coin概算値
        farming: 現在の+material概算値
        crafting: 現在の残り時間

    time
        1日86400秒をどの状態に振り分けるか
            mining, farming, crafting, resting
        mining: coin得る, str偏向
        farming: mat得る, dex偏向
        crafting: itemトライ, int偏向
        resting: grooming時にexp得る

    feeding, grooming, mining, farming, craftingの関係
        feeding:
            24時間でメーター0
            マイナスにはならない, 0→100のときに+exp
            どんなモード中でも可能
        grooming:
            resting中のみ可能
            72時間でメーター0
            マイナスにはならない
            +exp計算方法    ***TODO***
                その時点のlast_level_up_timeからのdelta_timeを算出
                last_total_mining_time, last_total_farming_timeを算出
                上記3つの数からlast_total_resting_timeを算出
                
            その時点のtotal_resting_timeを算出し, last_level_up_timeからのdelta_timeで割り、その係数分+exp
                つまり, 前回level-upから100%restingなら100%+exp, mining多くしてればexp減る
    satiety, happy, coin, materialのバランス, 消費タイミング, 補正
        materialはcrafting時に消費する基本資源, たくさん費やすほど成功率が上がる, 失敗しても減る
        coinはcraft成功時に支払われる資源, 成功時に減る
    level, str, dex, int, val, lukの補正方法, 上昇方法
        farming(dex), mining(str), crafting(int)のtotal timeでレベルアップ時のstatus換算を変える
        加えて、高コストだが木の実で能動的に上げることもできる
        valはno feeding/grooming timeが0で最大効率, valが高いと得られる経験値が増える?
        Level上昇による補正
            +1ですべての補正+5%
    items
        置物？動く？
        mining, farming, crafting補正アイテム
            1個で+5%有利になる
        exp補正アイテム → 制御が難しいので作らない
            expは献身性によってのみ得られる
        代わりにmining, farmingしてくれるペット
            Astar君、Ms. Astarとでも
            効率は本体の1/4～半分程度？
            成長はさせない？本体とともに効率が上がる
        大体, 3日で成功率80%に調整する
        すべて同じ効果だが、1個目, 2個目とdifficultyを上げる
            重ね効果を得にくいように。1個目作るのは安いが、2個目は高い、など

    ok satietyとhappyの差別化を考える。
    ok wallet所有のNFTを選べるUIを作る
    ok UI：Mintボタン, type指定可能に
    ok UI：所有summonerの表示と選択
    ok summon costの設定
        ok solidityのsummon関数にpayableをつける
        ok web3jsのvalueに0.1など追記
        ok solidityのsummonにrequiredでvalue閾値を追記
        ok solidityにwithdraw関数を追加

    Level-up
        last_feeding_time, last_grooming_time, expをすべてリセットする
        last_level_up_timeからnow.timeまでのdelta_timeを取得する
        delta_timeのうち, total_mining_time, total_farming_time, 残りをtotal_resting_timeとし
            それぞれのtotal_timeが何％か算出する
        point per level (1? 2?) をそれぞれのtotal_time割合で分割してパラメータに合算する


    ok stopのUI実装
        mining: 現在の+coin概算値
        farming: 現在の+material概算値
        crafting: 現在の残り時間



Donate: 0x2F7448B62134e52C2f46454d0089Ae21B5248805

    <form name="select_summoner">
        <input type="button" value="Update Summoner List" onclick="button_update_summoners();"/>
        <select name="select_summoner" id="summoner">
            <option value="***">***<option>
        </select>
        <input type="button" value="Swith Summoner" onclick="button_select_summoner();"/>
    </form>
    <br>

    ok craftingコントラの実装
    item craftingのUIの実装
    UI：所有itemのリアルタイム更新と表示
    コントラ：random
    コントラ：crafting, summonerが所有するNFT, 所有summonerを紐付けるよう書き換える
    コントラ：レベルアップの実装
    アイデア：coinのユースケースを考える
    アイデア：materialのバランスを考える


--->