// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;



/***

220221 v1.0.0

コントラを分割する
    mint時に決定し変化しない定数のstrage
        id
        class
        summoned_time
        summoned_wallet
    mint後に動的に変化する変数のstrage
        level
        exp
        str
        dex
        int
        luck
        coin
        material
    function群, 入り切らなければ2つなどにわける
    itemコントラクト, ERC721
        type
        crafted_time
        crafted_wallet
        crafted_summoner
***/


//---------------------------------------------------------------------------------------------------------------------
//Badge
//https://github.com/ra-phael/badge-token/tree/main/contracts/withoutTimestamp

interface IBadge {
	// @dev Emitted when `tokenId` token is minted to `to`, an address.
	event Minted(
		address indexed to,
		uint32 indexed tokenId,
		uint256 timestamp
	);

	// @dev Emitted when `tokenId` token is burned.
	event Burned(
		address indexed owner,
		uint32 indexed tokenId,
		uint256 timestamp
	);

	// @dev Returns the badge's name
	function name() external view returns (string memory);

	// @dev Returns the badge's symbol.
	function symbol() external view returns (string memory);

	// @dev Returns the ID of the token owned by `owner`, if it owns one, and 0 otherwise
	//function tokenOf(address owner) external view returns (bytes32);

	// @dev Returns the owner of the `tokenId` token.
	//function ownerOf(bytes32 tokenId) external view returns (address);
}

contract Badge is IBadge {
	// Badge's name
	string private _name;

	// Badge's symbol
	string private _symbol;

	// Mapping from token ID to owner's address
	mapping(uint32 => address) private _owners;

	// Mapping from owner's address to token ID
	mapping(address => uint32) private _tokens;

	constructor(string memory name_, string memory symbol_) {
		_name = name_;
		_symbol = symbol_;
	}

	// Returns the badge's name
	function name() public view virtual override returns (string memory) {
		return _name;
	}

	// Returns the badge's symbol
	function symbol() public view virtual override returns (string memory) {
		return _symbol;
	}

	// Returns the token ID owned by `owner`, if it exists, and 0 otherwise
	function tokenOf(address owner)
		public
		view
		virtual
		//override
		returns (uint32)
	{
		require(owner != address(0), "Invalid owner at zero address");

		return _tokens[owner];
	}

	// Returns the owner of a given token ID, reverts if the token does not exist
	function ownerOf(uint32 tokenId)
		public
		view
		virtual
		//override
		returns (address)
	{
		require(tokenId != 0, "Invalid tokenId value");

		address owner = _owners[tokenId];

		require(owner != address(0), "Invalid owner at zero address");

		return owner;
	}

	// Checks if a token ID exists
	function _exists(uint32 tokenId) internal view virtual returns (bool) {
		return _owners[tokenId] != address(0);
	}

	// @dev Mints `tokenId` and transfers it to `to`.
	function _mint(address to, uint32 tokenId) internal virtual {
		require(to != address(0), "Invalid owner at zero address");
		//require(tokenId != 0, "Token ID cannot be zero");
		require(!_exists(tokenId), "Token already minted");
		require(tokenOf(to) == 0, "Owner already has a token");

		_tokens[to] = tokenId;
		_owners[tokenId] = to;

		emit Minted(to, tokenId, block.timestamp);
	}

	// @dev Burns `tokenId`.
	function _burn(uint32 tokenId) internal virtual {
		address owner = Badge.ownerOf(tokenId);

		delete _tokens[owner];
		delete _owners[tokenId];

		emit Burned(owner, tokenId, block.timestamp);
	}
}



//---------------------------------------------------------------------------------------------------------------------
//Ownable

/**
 * @dev Provides information about the current execution context, including the
 * sender of the transaction and its data. While these are generally available
 * via msg.sender and msg.data, they should not be accessed in such a direct
 * manner, since when dealing with meta-transactions the account sending and
 * paying for execution may not be the actual sender (as far as an application
 * is concerned).
 *
 * This contract is only required for intermediate, library-like contracts.
 */
abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}

/**
 * @dev Contract module which provides a basic access control mechanism, where
 * there is an account (an owner) that can be granted exclusive access to
 * specific functions.
 *
 * By default, the owner account will be the one that deploys the contract. This
 * can later be changed with {transferOwnership}.
 *
 * This module is used through inheritance. It will make available the modifier
 * `onlyOwner`, which can be applied to your functions to restrict their use to
 * the owner.
 */
abstract contract Ownable is Context {
    address private _owner;
    RandomDataGuard internal _rdg;
    string internal _planetsBaseURI;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /**
     * @dev Initializes the contract setting the deployer as the initial owner.
     */
    constructor() {
        _setOwner(_msgSender());
    }

    /**
     * @dev Returns the address of the current owner.
     */
    function owner() public view virtual returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        require(owner() == _msgSender(), "Ownable: caller is not the owner");
        _;
    }
    
    function setRDG(address rdg)public virtual onlyOwner {
        _rdg = RandomDataGuard(rdg);    
    }

    function setBaseURI(string memory pBaseURI)public virtual onlyOwner {
        _planetsBaseURI = pBaseURI;    
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        _setOwner(newOwner);
    }

    function _setOwner(address newOwner) private {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}

interface RandomDataGuard {
    function randomGuard(uint256 random) external view returns(uint256);
}



//---------------------------------------------------------------------------------------------------------------------
//Base64

/// [MIT License]
/// @title Base64
/// @notice Provides a function for encoding some bytes in base64
/// @author Brecht Devos <brecht@loopring.org>
library Base64 {
    bytes internal constant TABLE = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

    /// @notice Encodes some bytes to the base64 representation
    function encode(bytes memory data) internal pure returns (string memory) {
        uint256 len = data.length;
        if (len == 0) return "";

        // multiply by 4/3 rounded up
        uint256 encodedLen = 4 * ((len + 2) / 3);

        // Add some extra buffer at the end
        bytes memory result = new bytes(encodedLen + 32);

        bytes memory table = TABLE;

        assembly {
            let tablePtr := add(table, 1)
            let resultPtr := add(result, 32)

            for {
                let i := 0
            } lt(i, len) {

            } {
                i := add(i, 3)
                let input := and(mload(add(data, i)), 0xffffff)

                let out := mload(add(tablePtr, and(shr(18, input), 0x3F)))
                out := shl(8, out)
                out := add(out, and(mload(add(tablePtr, and(shr(12, input), 0x3F))), 0xFF))
                out := shl(8, out)
                out := add(out, and(mload(add(tablePtr, and(shr(6, input), 0x3F))), 0xFF))
                out := shl(8, out)
                out := add(out, and(mload(add(tablePtr, and(input, 0x3F))), 0xFF))
                out := shl(224, out)

                mstore(resultPtr, out)

                resultPtr := add(resultPtr, 4)
            }

            switch mod(len, 3)
            case 1 {
                mstore(sub(resultPtr, 2), shl(240, 0x3d3d))
            }
            case 2 {
                mstore(sub(resultPtr, 1), shl(248, 0x3d))
            }

            mstore(result, encodedLen)
        }

        return string(result);
    }
}



//---------------------------------------------------------------------------------------------------------------------
//Murasaki Main

contract Murasaki_Main is Badge, Ownable{

    string constant internal _name = "House of Murasaki-san";
    string constant internal _symbol = "HMS";
    constructor(
    ) Badge(_name, _symbol) {}

    //static status
    mapping(uint32 => uint32) public class;
    mapping(uint32 => uint32) public summoned_time;

    //variants     
    uint32 public next_summoner = 1;
    //uint8  public PRICE = 0 ether;

    //address
    address public murasaki_function_address;

    //contract
    //Murasaki_Function mf = Murasaki_Function(murasaki_function_address);

    //admin, set variants
    //function set_price(uint8 _price) public onlyOwner {
    //    PRICE = _price;
    //}

    //admin, set address
    function _set_murasaki_function_address(address _address) public onlyOwner {
        murasaki_function_address = _address;
    }

    //admin. withdraw
    //function withdraw(address rec)public onlyOwner{
    //    payable(rec).transfer(address(this).balance);
    //}

    //summon
    function summon(address _owner, uint32 _class) external returns (uint32) {
        require(msg.sender == murasaki_function_address);
        //require(msg.value >= PRICE);
        //require(0 <= _class && _class <= 11);
        //Murasaki_Function mf = Murasaki_Function(murasaki_function_address);
        uint32 _now = uint32(block.timestamp);
        uint32 _next_summoner = next_summoner;
        class[_next_summoner] = _class;
        summoned_time[_next_summoner] = _now;
        //mint
        _mint(_owner, _next_summoner);
        //initialize strage
        //mf.summon(next_summoner);
        next_summoner++;
        return _next_summoner;
    }

    //URI
    function toString(uint256 value) internal pure returns (string memory) {
    // Inspired by OraclizeAPI's implementation - MIT license
    // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol
        if (value == 0) {
            return "0";
        }
        uint256 temp = value;
        uint256 digits;
        while (temp != 0) {
            digits++;
            temp /= 10;
        }
        bytes memory buffer = new bytes(digits);
        while (value != 0) {
            digits -= 1;
            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));
            value /= 10;
        }
        return string(buffer);
    }
    function tokenURI (uint32 _summoner) public view returns (string memory) {
        string[9] memory parts;
        parts[0] = '<svg xmlns="http://www.w3.org/2000/svg" preserveAspectRatio="xMinYMin meet" viewBox="0 0 350 350"><style>.base { fill: white; font-family: serif; font-size: 14px; }</style><rect width="100%" height="100%" fill="black" /><text x="10" y="20" class="base">';
        parts[1] = string(abi.encodePacked("class", " ", toString(class[_summoner])));
        parts[2] = '</text><text x="10" y="40" class="base">';
        parts[3] = string(abi.encodePacked("summoned time", " ", toString(summoned_time[_summoner])));
        parts[8] = '</text></svg>';
        string memory output = string(abi.encodePacked(parts[0], parts[1], parts[2], parts[3], parts[4], parts[5], parts[6], parts[7], parts[8]));
        string memory json = Base64.encode(bytes(string(abi.encodePacked('{"name": "summoner #', toString(_summoner), '", "description": "Murasaki-san", "image": "data:image/svg+xml;base64,', Base64.encode(bytes(output)), '"}'))));
        output = string(abi.encodePacked('data:application/json;base64,', json));
        return output;
    }
}



//---------------------------------------------------------------------------------------------------------------------
//Murasaki Function

contract Murasaki_Function is Ownable {

    //address
    address public murasaki_strage_address;
    address public murasaki_main_address;

    //variants
    uint32 public BASE_SEC = 86400;
    uint32 public SPEED = 1;
    uint32 public PRICE = 0 ether;

    //admin
    function _set_base_sec(uint32 _base_sec) external onlyOwner {
        BASE_SEC = _base_sec;
    }
    function _set_speed(uint32 _speed) external onlyOwner {
        SPEED = _speed;
    }
    function _set_murasaki_strage_address(address _address) external onlyOwner {
        murasaki_strage_address = _address;
    }
    function _set_murasaki_main_address(address _address) external onlyOwner {
        murasaki_main_address = _address;
    }
    function set_price(uint8 _price) external onlyOwner {
        PRICE = _price;
    }

    //admin. withdraw
    function withdraw(address rec)public onlyOwner{
        payable(rec).transfer(address(this).balance);
    }

    //contract
    //Murasaki_Main mm = Murasaki_Main(murasaki_main_address);
    //Murasaki_Strage ms = Murasaki_Strage(murasaki_strage_address);

    //summon, only from murasaki_main
    function summon(uint32 _class) external payable {
        require(msg.value >= PRICE);
        require(0 <= _class && _class <= 11);
        //summon on mm, mint NTT
        Murasaki_Main mm = Murasaki_Main(murasaki_main_address);
        uint32 _summoner = mm.summon(msg.sender, _class);
        //summon on ms, initialize sutatus
        Murasaki_Strage ms = Murasaki_Strage(murasaki_strage_address);
        uint32 _now = uint32(block.timestamp);
        ms.set_level(_summoner, 1);
        ms.set_exp(_summoner, 0);
        ms.set_strength(_summoner, 500);
        ms.set_dexterity(_summoner, 500);
        ms.set_intelligence(_summoner, 500);
        ms.set_luck(_summoner, 500);
        ms.set_next_exp_required(_summoner, 1000);
        ms.set_last_level_up_time(_summoner, _now);
        ms.set_coin(_summoner, 0);
        ms.set_material(_summoner, 0);
        ms.set_last_feeding_time(_summoner, _now - BASE_SEC/4);
        ms.set_last_grooming_time(_summoner, _now - BASE_SEC/4);
        ms.set_mining_status(_summoner, 0);
        ms.set_mining_start_time(_summoner, 0);
        ms.set_farming_status(_summoner, 0);
        ms.set_farming_start_time(_summoner, 0);
        ms.set_crafting_status(_summoner, 0);
        ms.set_crafting_start_time(_summoner, 0);
        ms.set_crafting_item_type(_summoner, 0);
        ms.set_total_mining_sec(_summoner, 0);
        ms.set_total_farming_sec(_summoner, 0);
        ms.set_total_crafting_sec(_summoner, 0);
        ms.set_last_total_mining_sec(_summoner, 0);
        ms.set_last_total_farming_sec(_summoner, 0);
        ms.set_last_total_crafting_sec(_summoner, 0);
        ms.set_last_grooming_time_plus_working_time(_summoner, _now - BASE_SEC/4);
    }

    //feeding
    function feeding(uint32 _summoner) external {
        Murasaki_Main mm = Murasaki_Main(murasaki_main_address);
        Murasaki_Strage ms = Murasaki_Strage(murasaki_strage_address);
        require(mm.ownerOf(_summoner) == msg.sender);
        uint32 _now = uint32(block.timestamp);
        uint32 _exp = ms.exp(_summoner);
        uint32 _satiety = calc_feeding(_summoner);
        _exp += 1000 * (100 - _satiety) / 100;
        ms.set_exp(_summoner, _exp);
        ms.set_last_feeding_time(_summoner, _now);
    }
    function calc_feeding(uint32 _summoner) public view returns (uint32) {
        Murasaki_Strage ms = Murasaki_Strage(murasaki_strage_address);
        uint32 _now = uint32(block.timestamp);
        uint32 _delta_sec = _now - ms.last_feeding_time(_summoner);
        uint32 _base = BASE_SEC /2 /SPEED;
        uint32 _satiety;
        if (_delta_sec >= _base) {
            _satiety = 0;
        }else {
            _satiety = 100 * (_base - _delta_sec) / _base;
        }
        return _satiety;
    }

    //grooming
    function grooming(uint32 _summoner) external {
        Murasaki_Main mm = Murasaki_Main(murasaki_main_address);
        Murasaki_Strage ms = Murasaki_Strage(murasaki_strage_address);
        require(mm.ownerOf(_summoner) == msg.sender);
        uint32 _now = uint32(block.timestamp);
        uint32 _exp = ms.exp(_summoner);
        uint32 _happy = calc_grooming(_summoner);
        _exp += 6000 * (100 - _happy) / 100;
        ms.set_exp(_summoner, _exp);
        ms.set_last_grooming_time(_summoner, _now);
    }
    function calc_grooming(uint32 _summoner) public view returns (uint32) {
        Murasaki_Strage ms = Murasaki_Strage(murasaki_strage_address);
        uint32 _now = uint32(block.timestamp);
        uint32 _delta_sec = _now - ms.last_grooming_time(_summoner);
        uint32 _base = BASE_SEC *3 /SPEED;
        uint32 _happy;
        if (_delta_sec >= _base) {
            _happy = 0;
        }else {
            _happy = 100 * (_base - _delta_sec) / _base;
        }
        return _happy;
    }

    //mining
    function start_mining(uint32 _summoner) external {
        Murasaki_Main mm = Murasaki_Main(murasaki_main_address);
        Murasaki_Strage ms = Murasaki_Strage(murasaki_strage_address);
        require(mm.ownerOf(_summoner) == msg.sender);
        require(ms.mining_status(_summoner) == 0 && ms.farming_status(_summoner) == 0 && ms.crafting_status(_summoner) == 0);
        require(calc_feeding(_summoner) >= 20 && calc_grooming(_summoner) >= 20);
        //require(ms.level(_summoner) >= 2);
        uint32 _now = uint32(block.timestamp);
        ms.set_mining_status(_summoner, 1);
        ms.set_mining_start_time(_summoner, _now);
    }
    function stop_mining(uint32 _summoner) external {
        Murasaki_Main mm = Murasaki_Main(murasaki_main_address);
        Murasaki_Strage ms = Murasaki_Strage(murasaki_strage_address);
        require(mm.ownerOf(_summoner) == msg.sender);
        require(ms.mining_status(_summoner) == 1);
        uint32 _now = uint32(block.timestamp);
        uint32 _delta = calc_mining(_summoner);
        //luck modification
        if (d100(_summoner) <= ms.luck(_summoner)/100) {
            _delta = _delta *2;
        }
        //add coin
        uint32 _coin = ms.coin(_summoner) + _delta;
        ms.set_coin(_summoner, _coin);
        //update timestamp
        uint32 _delta_sec = _now - ms.mining_start_time(_summoner);
        uint32 _total_mining_sec = ms.total_mining_sec(_summoner) + _delta_sec;
        ms.set_total_mining_sec(_summoner, _total_mining_sec);
        uint32 _last_total_mining_sec = ms.last_total_mining_sec(_summoner) + _delta_sec;
        ms.set_last_total_mining_sec(_summoner, _last_total_mining_sec);
        uint32 _last_grooming_time_plus_working_time = ms.last_grooming_time_plus_working_time(_summoner) + _delta_sec;
        ms.set_last_grooming_time_plus_working_time(_summoner, _last_grooming_time_plus_working_time);
        ms.set_mining_status(_summoner, 0);
    }
    function calc_mining(uint32 _summoner) public view returns (uint32) {
        Murasaki_Strage ms = Murasaki_Strage(murasaki_strage_address);
        require(ms.mining_status(_summoner) == 1);
        uint32 _now = uint32(block.timestamp);
        uint32 _delta = (_now - ms.mining_start_time(_summoner)) * SPEED / 100;
        _delta += ( _delta * ms.strength(_summoner) / 100 ) / 100;
        _delta += ( _delta * ms.level(_summoner) ) / 100;
        return _delta;
    }

    //farming
    function start_farming(uint32 _summoner) external {
        Murasaki_Main mm = Murasaki_Main(murasaki_main_address);
        Murasaki_Strage ms = Murasaki_Strage(murasaki_strage_address);
        require(mm.ownerOf(_summoner) == msg.sender);
        require(ms.mining_status(_summoner) == 0 && ms.farming_status(_summoner) == 0 && ms.crafting_status(_summoner) == 0);
        require(calc_feeding(_summoner) >= 20 && calc_grooming(_summoner) >= 20);
        //require(ms.level(_summoner) >= 2);
        uint32 _now = uint32(block.timestamp);
        ms.set_farming_status(_summoner, 1);
        ms.set_farming_start_time(_summoner, _now);
    }
    function stop_farming(uint32 _summoner) external {
        Murasaki_Main mm = Murasaki_Main(murasaki_main_address);
        Murasaki_Strage ms = Murasaki_Strage(murasaki_strage_address);
        require(mm.ownerOf(_summoner) == msg.sender);
        require(ms.farming_status(_summoner) == 1);
        uint32 _now = uint32(block.timestamp);
        uint32 _delta = calc_farming(_summoner);
        //luck modification
        if (d100(_summoner) <= ms.luck(_summoner)/100) {
            _delta = _delta *2;
        }
        //add coin
        uint32 _material = ms.material(_summoner) + _delta;
        ms.set_material(_summoner, _material);
        //update timestamp
        uint32 _delta_sec = _now - ms.farming_start_time(_summoner);
        uint32 _total_farming_sec = ms.total_farming_sec(_summoner) + _delta_sec;
        ms.set_total_farming_sec(_summoner, _total_farming_sec);
        uint32 _last_total_farming_sec = ms.last_total_farming_sec(_summoner) + _delta_sec;
        ms.set_last_total_farming_sec(_summoner, _last_total_farming_sec);
        uint32 _last_grooming_time_plus_working_time = ms.last_grooming_time_plus_working_time(_summoner) + _delta_sec;
        ms.set_last_grooming_time_plus_working_time(_summoner, _last_grooming_time_plus_working_time);
        ms.set_farming_status(_summoner, 0);
    }
    function calc_farming(uint32 _summoner) public view returns (uint32) {
        Murasaki_Strage ms = Murasaki_Strage(murasaki_strage_address);
        require(ms.farming_status(_summoner) == 1);
        uint32 _now = uint32(block.timestamp);
        uint32 _delta = (_now - ms.farming_start_time(_summoner)) * SPEED / 100;
        _delta += ( _delta * ms.dexterity(_summoner) / 100 ) / 1000;
        _delta += ( _delta * ms.level(_summoner) ) / 1000;
        return _delta;
    }

    //level-up
    function level_up(uint32 _summoner) external {
        Murasaki_Main mm = Murasaki_Main(murasaki_main_address);
        Murasaki_Strage ms = Murasaki_Strage(murasaki_strage_address);
        require(mm.ownerOf(_summoner) == msg.sender);
        require(ms.mining_status(_summoner) == 0 && ms.farming_status(_summoner) == 0 && ms.crafting_status(_summoner) == 0);
        require(ms.exp(_summoner) >= ms.next_exp_required(_summoner));
        uint32 _now = uint32(block.timestamp);
        //calculate working percent
        uint32 _base_sec = _now - ms.last_level_up_time(_summoner);
        uint32 _resting_sec = _base_sec - ms.last_total_mining_sec(_summoner) - ms.last_total_farming_sec(_summoner) - ms.last_total_crafting_sec(_summoner);
        uint32 _percent_mining = 200 * (ms.last_total_mining_sec(_summoner) + _resting_sec/4) / _base_sec;
        uint32 _percent_farming = 200 * (ms.last_total_farming_sec(_summoner) + _resting_sec/4) / _base_sec;
        uint32 _percent_crafting = 200 * (ms.last_total_crafting_sec(_summoner) + _resting_sec/4) / _base_sec;
        uint32 _percent_resting = 200 * (_resting_sec/4) / _base_sec;
        //status addition
        ms.set_strength(_summoner, ms.strength(_summoner) + _percent_mining);
        ms.set_dexterity(_summoner, ms.dexterity(_summoner) + _percent_farming);
        ms.set_intelligence(_summoner, ms.intelligence(_summoner) + _percent_crafting);
        ms.set_luck(_summoner, ms.luck(_summoner) + _percent_resting);
        //update timestamp
        ms.set_last_total_mining_sec(_summoner, 0);
        ms.set_last_total_farming_sec(_summoner, 0);
        ms.set_last_total_crafting_sec(_summoner, 0);
        //reset feeding, grooming, and exp
        ms.set_last_feeding_time(_summoner, _now);
        ms.set_last_grooming_time(_summoner, _now);
        ms.set_exp(_summoner, 0);
        //level-up
        uint32 _next_level = ms.level(_summoner) + 1;
        ms.set_level(_summoner, _next_level);
        ms.set_last_level_up_time(_summoner, _now);
        //update next_exp_required
        if (_next_level == 2) {
            ms.set_next_exp_required(_summoner, 3000);
        }else if (_next_level == 3) {
            ms.set_next_exp_required(_summoner, 6000);
        }else if (_next_level == 4) {
            ms.set_next_exp_required(_summoner, 10000);
        }else if (_next_level == 5) {
            ms.set_next_exp_required(_summoner, 15000);
        }else if (_next_level == 6) {
            ms.set_next_exp_required(_summoner, 21000);
        }else if (_next_level == 7) {
            ms.set_next_exp_required(_summoner, 28000);
        }else if (_next_level == 8) {
            ms.set_next_exp_required(_summoner, 36000);
        }else if (_next_level == 9) {
            ms.set_next_exp_required(_summoner, 45000);
        }else if (_next_level == 10) {
            ms.set_next_exp_required(_summoner, 55000);
        }else if (_next_level == 11) {
            ms.set_next_exp_required(_summoner, 66000);
        }else if (_next_level == 12) {
            ms.set_next_exp_required(_summoner, 78000);
        }else if (_next_level == 13) {
            ms.set_next_exp_required(_summoner, 91000);
        }else if (_next_level == 14) {
            ms.set_next_exp_required(_summoner, 105000);
        }else if (_next_level == 15) {
            ms.set_next_exp_required(_summoner, 120000);
        }else if (_next_level == 16) {
            ms.set_next_exp_required(_summoner, 136000);
        }else if (_next_level == 17) {
            ms.set_next_exp_required(_summoner, 153000);
        }else if (_next_level == 18) {
            ms.set_next_exp_required(_summoner, 171000);
        }else if (_next_level == 19) {
            ms.set_next_exp_required(_summoner, 190000);
        }
    }

    /*
    //crafting
    function start_crafting(uint32 _summoner) public {
    }
    function stop_crafting(uint32 _summoner) public {
    }
    function calc_crafting(uint32 _summoner) public view returns (uint32) {
    }
    */

    //dice codex
    /* #********#
    function d100(uint _summoner) internal view returns (uint) {
        return dn(_summoner, 100);
    }
    */
    function d100(uint _summoner) internal pure returns (uint) {
        return _summoner * 0 + 10;
    }    
    function d20(uint _summoner) internal view returns (uint) {
        return dn(_summoner, 20);
    }
    function d12(uint _summoner) internal view returns (uint) {
        return dn(_summoner, 12);
    }    
    function d10(uint _summoner) internal view returns (uint) {
        return dn(_summoner, 10);
    }    
    function d8(uint _summoner) internal view returns (uint) {
        return dn(_summoner, 8);
    }    
    function d6(uint _summoner) internal view returns (uint) {
        return dn(_summoner, 6);
    }    
    function d4(uint _summoner) internal view returns (uint) {
        return dn(_summoner, 4);
    }    
    function dn(uint _summoner, uint _number) public view returns (uint) {
        return _seed(_summoner) % _number;
    }    
    function _random(string memory input) internal pure returns (uint256) {
        return uint256(keccak256(abi.encodePacked(input)));
    }    
    function _seed(uint _summoner) internal view returns (uint rand) {
        rand = _random(
            string(
                abi.encodePacked(
                    block.timestamp,
                    blockhash(block.number - 1),
                    _summoner,
                    msg.sender
                )
            )
        );
    }
}



//---------------------------------------------------------------------------------------------------------------------
//Murasaki Strage

contract Murasaki_Strage is Ownable {

    //permitted address
    mapping(address => bool) public permitted_address;

    //global variants
    uint32 public BASE_SEC = 86400;
    uint32 public SPEED = 1;
    uint32 public PRICE = 0 ether;    

    //dynamic, status
    mapping(uint32 => uint32) public level;
    mapping(uint32 => uint32) public exp;
    mapping(uint32 => uint32) public strength;
    mapping(uint32 => uint32) public dexterity;
    mapping(uint32 => uint32) public intelligence;
    mapping(uint32 => uint32) public luck;
    mapping(uint32 => uint32) public next_exp_required;
    mapping(uint32 => uint32) public last_level_up_time;

    //dymanic, resouse
    mapping(uint32 => uint32) public coin;
    mapping(uint32 => uint32) public material;

    //dynamic, treating
    mapping(uint32 => uint32) public last_feeding_time;
    mapping(uint32 => uint32) public last_grooming_time;

    //dynamic, working
    mapping(uint32 => uint32) public mining_status;
    mapping(uint32 => uint32) public mining_start_time;
    mapping(uint32 => uint32) public farming_status;
    mapping(uint32 => uint32) public farming_start_time;
    mapping(uint32 => uint32) public crafting_status;
    mapping(uint32 => uint32) public crafting_start_time;
    mapping(uint32 => uint32) public crafting_item_type;
    mapping(uint32 => uint32) public total_mining_sec;
    mapping(uint32 => uint32) public total_farming_sec;
    mapping(uint32 => uint32) public total_crafting_sec;
    mapping(uint32 => uint32) public last_total_mining_sec;
    mapping(uint32 => uint32) public last_total_farming_sec;
    mapping(uint32 => uint32) public last_total_crafting_sec;
    mapping(uint32 => uint32) public last_grooming_time_plus_working_time;

    //permitted address
    address public murasaki_function_address;

    //admin
    function _set_murasaki_function_address(address _address) external onlyOwner {
        murasaki_function_address = _address;
    }
    function _add_permitted_address(address _address) external onlyOwner {
        permitted_address[_address] = True;
    }

    //set status
    function set_level(uint32 _summoner, uint32 _value) external {
        require(msg.sender == murasaki_function_address);
        level[_summoner] = _value;
    }
    function set_exp(uint32 _summoner, uint32 _value) external {
        require(msg.sender == murasaki_function_address);
        exp[_summoner] = _value;
    }
    function set_strength(uint32 _summoner, uint32 _value) external {
        require(msg.sender == murasaki_function_address);
        strength[_summoner] = _value;
    }
    function set_dexterity(uint32 _summoner, uint32 _value) external {
        require(msg.sender == murasaki_function_address);
        dexterity[_summoner] = _value;
    }
    function set_intelligence(uint32 _summoner, uint32 _value) external {
        require(msg.sender == murasaki_function_address);
        intelligence[_summoner] = _value;
    }
    function set_luck(uint32 _summoner, uint32 _value) external {
        require(msg.sender == murasaki_function_address);
        luck[_summoner] = _value;
    }
    function set_next_exp_required(uint32 _summoner, uint32 _value) external {
        require(msg.sender == murasaki_function_address);
        next_exp_required[_summoner] = _value;
    }
    function set_last_level_up_time(uint32 _summoner, uint32 _value) external {
        require(msg.sender == murasaki_function_address);
        last_level_up_time[_summoner] = _value;
    }
    function set_coin(uint32 _summoner, uint32 _value) external {
        require(msg.sender == murasaki_function_address);
        coin[_summoner] = _value;
    }
    function set_material(uint32 _summoner, uint32 _value) external {
        require(msg.sender == murasaki_function_address);
        material[_summoner] = _value;
    }
    function set_last_feeding_time(uint32 _summoner, uint32 _value) external {
        require(msg.sender == murasaki_function_address);
        last_feeding_time[_summoner] = _value;
    }
    function set_last_grooming_time(uint32 _summoner, uint32 _value) external {
        require(msg.sender == murasaki_function_address);
        last_grooming_time[_summoner] = _value;
    }
    function set_mining_status(uint32 _summoner, uint32 _value) external {
        require(msg.sender == murasaki_function_address);
        mining_status[_summoner] = _value;
    }
    function set_mining_start_time(uint32 _summoner, uint32 _value) external {
        require(msg.sender == murasaki_function_address);
        mining_start_time[_summoner] = _value;
    }
    function set_farming_status(uint32 _summoner, uint32 _value) external {
        require(msg.sender == murasaki_function_address);
        farming_status[_summoner] = _value;
    }
    function set_farming_start_time(uint32 _summoner, uint32 _value) external {
        require(msg.sender == murasaki_function_address);
        farming_start_time[_summoner] = _value;
    }
    function set_crafting_status(uint32 _summoner, uint32 _value) external {
        require(msg.sender == murasaki_function_address);
        crafting_status[_summoner] = _value;
    }
    function set_crafting_start_time(uint32 _summoner, uint32 _value) external {
        require(msg.sender == murasaki_function_address);
        crafting_start_time[_summoner] = _value;
    }
    function set_crafting_item_type(uint32 _summoner, uint32 _value) external {
        require(msg.sender == murasaki_function_address);
        crafting_item_type[_summoner] = _value;
    }
    function set_total_mining_sec(uint32 _summoner, uint32 _value) external {
        require(msg.sender == murasaki_function_address);
        total_mining_sec[_summoner] = _value;
    }
    function set_total_farming_sec(uint32 _summoner, uint32 _value) external {
        require(msg.sender == murasaki_function_address);
        total_farming_sec[_summoner] = _value;
    }
    function set_total_crafting_sec(uint32 _summoner, uint32 _value) external {
        require(msg.sender == murasaki_function_address);
        total_crafting_sec[_summoner] = _value;
    }
    function set_last_total_mining_sec(uint32 _summoner, uint32 _value) external {
        require(msg.sender == murasaki_function_address);
        last_total_mining_sec[_summoner] = _value;
    }
    function set_last_total_farming_sec(uint32 _summoner, uint32 _value) external {
        require(msg.sender == murasaki_function_address);
        last_total_farming_sec[_summoner] = _value;
    }
    function set_last_total_crafting_sec(uint32 _summoner, uint32 _value) external {
        require(msg.sender == murasaki_function_address);
        last_total_crafting_sec[_summoner] = _value;
    }
    function set_last_grooming_time_plus_working_time(uint32 _summoner, uint32 _value) external {
        require(msg.sender == murasaki_function_address);
        last_grooming_time_plus_working_time[_summoner] = _value;
    }

}