contract Murasaki_Mail is Ownable {

    //address
    address public murasaki_function_share_address;
    function _set1_murasaki_function_share_address(address _address) external onlyOwner {
        murasaki_function_share_address = _address;
    }
    address public murasaki_function_crafting_address;
    function _set2_murasaki_function_crafting_address(address _address) external onlyOwner {
        murasaki_function_crafting_address = _address;
    }
    
    /*
    //mapping
    mapping(uint32 => uint32) public sending_from2to;     //[_summoner_from] = _summoner_to
    mapping(uint32 => uint32) public sending_to2from;     //[_summoner_to] = _summoner_from
    mapping(uint32 => uint32) public last_sending_time;     //[_summoner_from] = block.time
    mapping(uint32 => uint32) public last_receving_time;    //[_summoner_to] = block.time
    */
    
    //mail
    struct Mail {
        uint32 send_time;
        uint32 open_time;
        uint32 summoner_from;
        uint32 summoner_to;
    }
    mapping(uint32 => Mail) public mails;

    //mapping
    mapping(uint32 => uint32) public sending;   //[_summoner_from] = mails;
    mapping(uint32 => uint32) public receving;  //[_summoner_to] = mails;
    
    //variants
    //interval, both of sending interval & receving limit
    uint32 interval_sec = 60 * 60 * 24 * 3;    // 3 days
    uint32 item_type_of_mail = 196;
    
    //check mail
    function check_receving_mail(uint32 _summoner_to) public view returns (bool) {
        if (
            last_receving_time[_summoner_to] <= interval_sec  //recieving limit
            && sending_to2from[_summoner_to] != 0
        ) {
            return true;
        } else {
            return false;
        }
    }
    
    //calc sending interval
    function calc_sending_interval(uint32 _summoner_from) public view returns (uint32) {
        uint32 _now = uint32(block.timestamp);
        uint32 _delta = _now - last_sending_time[_summoner_from];
        if (_delta >= interval_sec) {
            return 0;
        } else {
            return interval_sec - _delta;
        }
    }
    
    //send mail
    function send_mail(uint32 _summoner_from, uint32 _item_mail) external {
        Murasaki_Function_Share mfs = Murasaki_Function_Share(murasaki_function_share_address);
        //check owner
        require(mfs.check_owner(_summoner_from, msg.sender));
        //check sending interval
        require(calc_sending_interval(_summoner_from) == 0);
        //check _item_mail
        Murasaki_Craft mc = Murasaki_Craft(mfs.murasaki_craft_address());
        (uint32 _item_type, , ,) = mc.items(_item_mail);
        require(_item_type == item_type_of_mail);
        require(mc.ownerOf(_item_mail) == msg.sender);
        //burn mail nft
        _burn_mail(_item_mail);
        //select _summoner_to
        uint32 _summoner_to = _select_random_summoner_to(_summoner_from);
        //send mail
        sending_from2to[_summoner_from] = _summoner_to;
        sending_to2from[_summoner_to] = _summoner_from;
        uint32 _now = uint32(block.timestamp);
        last_sending_time[_summoner_from] = _now;
        last_receving_time[_summoner_to] = _now;
    }
    function _select_random_summoner_to(uint32 _summoner_from) internal view returns (uint32) {
        Murasaki_Function_Share mfs = Murasaki_Function_Share(murasaki_function_share_address);
        Murasaki_Main mm = Murasaki_Main(mfs.murasaki_main_address());
        uint32 _count_summoners = mm.next_summoner() - 1;
        uint32 _summoner_to = mfs.dn(_summoner_from, _count_summoners) + 1;
        return _summoner_to;
    }
    function _burn_mail(uint32 _item_mail) internal {
        //prior approval required
        Murasaki_Function_Share mfs = Murasaki_Function_Share(murasaki_function_share_address);
        Murasaki_Craft mc = Murasaki_Craft(mfs.murasaki_craft_address());
        mc.transferFrom(msg.sender, address(this), _item_mail);
    }
    
    //open mail
    function open_mail(uint32 _summoner_to) external {
        Murasaki_Function_Share mfs = Murasaki_Function_Share(murasaki_function_share_address);
        //check owner
        require(mfs.check_owner(_summoner_to, msg.sender));
        //check receving mail
        require(check_receving_mail(_summoner_to));
        //get _summoner_from
        uint32 _summoner_from = sending_to2from[_summoner_to];
        //reset parameters
        sending_to2from[_summoner_to] = 0;
        //mint heart
        _create_tiny_heart(_summoner_to, _summoner_from);
    }
    function _create_tiny_heart(uint32 _summoner_to, uint32 _summoner_from) internal {
        //Murasaki_Function_Share mfs = Murasaki_Function_Share(murasaki_function_share_address);
        Murasaki_Function_Crafting mfc = Murasaki_Function_Crafting(murasaki_function_crafting_address);
        mfc.create_tiny_heart(_summoner_to, _summoner_from);
    }
}
