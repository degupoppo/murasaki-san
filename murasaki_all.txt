
//------------------------------------------------------------------------------------------------------------------
/***

    バランス調整
        Lv1上がる日数
        1日に得られるcoin
        1日に得られるmaterial
        craftに費やす日数
        +1ポイントの補正値
            +1%？+2%？
        1年後のインフレ率
            +100%程度かもう少し多くするか
            +100%にインフレするのに何ヶ月の設定にするか
            そのインフレ率で後半itemのクラフトは可能か
        ポイントごとの補正は線形か非線形か
            割合減少だと後半のアイテムがいつまでたっても作れない
            +100%で効率2倍に上がったとしても, DCが10倍のアイテムを作るのは大変
            基準は1日として、後半のアイテムも1年後に一日で作れる程度に軟化させる
                その状態でも、初期アイテムが例えば1秒で完成したりはしない。
       *クラフト時の補正を考える
            単純に-X%していくと初期アイテムの無価値化が進む
            3日程度をリミットに収束するよう数式を考える
            逆に、strとdexは線形インフレでよいか
            後半のほうがレベルが上がりにくくなるので、自然と鈍化する

    ゆっくりと成長する木の実装
        item type = 50ぐらいの専用スロット
        成長するまで何が生えるかわからない
        summonerの行動によって結果がかわる
        1ヶ月で最大成長ぐらいか

    マーケットプレイスの実装
        ERC721に準じるもので良さそう
            rarityのマーケットが参考になるか
        itemのみ売買可能
        所持item一覧の実装
        売りに出しているitem一覧の実装
        売買マージンの導入

    NFTステーキングの実装
        ステーキング専用の高価なitemを作る
        このitemは作った後にstakingすることで何かしらのリワードが得られる
            ゲーム内の通貨か、Astarか

 ok ワールドダイスの実装
        mmに係数を追加
            ワールドダイスコントラからしか書き換えられないようにする
        クラフト品とする, 少し高めのコスト設定
        すべての補正+1～20%
        utc 0時以降, その日の分を振れる
        何かしらの判定時に, ダイス振ってあったら+補正
            utc 0時以前がlast_dice時間ならば補正なし
        Luck補正を利用する
        ダイス補正の期待値+10.5%を織り込んでバランス設計する
        乱数の実装

 ok craft NFTのURIの実装
        mmを流用

 ok coinとmaterialのtransfer関数の実装
        miscファンクション群として別コントラに作るか
        機能としてはstrageコントラのset_coinを使ってラップ関数を実装するだけでよい

 ok itemリストの再整備
        str, dex, int, luk, その他か
        12 + 12 + 12 + 12 + 12 = 60？

 ok たまご化の実装
        石化にする
        一定時間放置していると卵化する
        もとに戻すにはLv x 10程度のAstarが必要
        working中はどうする？
        satietyのみを基準とする
            last_feeding_timeが30日以上経過していたら石化させる
            石化を解くまではfeedingできない
            feedingできないとsatietyが20%以下なのでworkingできない
            workingステータスは石化を解いたときにすべて0にリセットされる

 ok itemのrarity設定
        +1-2の範囲で補正を変える
        +2補正のアイテムはd20=20とかレアにする
        補正値をmm側で参照するシステムが一番の難点か
        itemを128まで拡張してrare判定成功時は+64に入れる
            item補正時は+64番も参照してそっちにあれば補正+2, ノーマルなら+1
            フロントエンドもそれに準じる
            また、フロントエンドではrareで表示を変える
    
 ok item, pet NFTの譲渡の実装
        update関数の実装
            mm側に用意し, mcとmpのowner_summonerおよびwallet onwerをすべてチェックしてfalseを0に置換する
        1つのpet/itemが2つ以上のsummonerに紐付け可能なことを回避する実装を考える
        → 上記ERC721の改変で解決可能

 ok item集計法の実装
        ERC721内にitem_typeごとの各アドレスのbalanceOf関数を実装する
        該当範囲のitem_typeをforで見て, balanceOf>0の数をカウントする
        同じtypeは何個持っていても関係ない。
        この方法ならば、ERC721規格に従ってやり取りしても辻褄があう

 ok itemの補正方法の修正
        1つ所持するとステータス+1もしくは+2の補正で
        わかりやすくすべてステータス値に換算させる
        補正はあくまでステータス値の合計値で行う

 ok リファクタリング
        容量限界に付き、コードのスリム化 or 別コントラ化
        coin, materialをそれぞれ別にするか
        summonerパラメータのstruct化
        exp_next_requiredなどはライブラリ化して別コントラとするか
        strageとlogicを別にする
        普遍的なstatic statusと書き換えるdynamic statusを別コントラとする
            static, summoner:
                id
                class
                birth_time
                crafted_wallet
            static, item:
                id
                type
                crafted_time
                crafted_summoner
                crafted_wallet
        つまり, strage contractはstatic status, dynamic statusの2種類
            static statusの方にERC721を紐付ける
        logical contractはテーマごとに別々に
            strageは一切保存させない
            approve mappingを作る
                mapping address bool で, approveならばtrue
                function呼び出し時にapproveアドレスを参照させる
                approveアドレスを書き換える関数を作っておく, owner only権限
        strage contractはlogical contractからのsendのみすべて許可する
        logical contract側でownなどをその都度チェックする
            基本的には, ERC721のownを参照でよいか

 ok Luckの補正の実装
        feeding/grooming時に+αでexp得る確率
        stop mining/farming時に+αでcoin/material得る確率
        crafting時に割引で行える確率

 ok Vitステータスの削除

 ok URIの実装
        rarity方式にするか
        murasakiアイコン＋levelにするか
        base64等のURI関数の実装

 ok mining, farming, craftingの要求レベルの実装

***/



// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;



//---------------------------------------------------------------------------------------------------------------------
//RC721

interface IERC721 {
    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);
    function balanceOf(address owner) external view returns (uint256 balance);
    function ownerOf(uint256 tokenId) external view returns (address owner);
    function safeTransferFrom(
        address from,
        address to,
        uint256 tokenId
    ) external;
    function transferFrom(
        address from,
        address to,
        uint256 tokenId
    ) external;
    function approve(address to, uint256 tokenId) external;
    function getApproved(uint256 tokenId) external view returns (address operator);
    function setApprovalForAll(address operator, bool _approved) external;
    function isApprovedForAll(address owner, address operator) external view returns (bool);
    function safeTransferFrom(
        address from,
        address to,
        uint256 tokenId,
        bytes calldata data
    ) external;
}

library Strings {
    function toString(uint256 value) internal pure returns (string memory) {
        if (value == 0) {
            return "0";
        }
        uint256 temp = value;
        uint256 digits;
        while (temp != 0) {
            digits++;
            temp /= 10;
        }
        bytes memory buffer = new bytes(digits);
        while (value != 0) {
            digits -= 1;
            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));
            value /= 10;
        }
        return string(buffer);
    }
}

interface IERC721Receiver {
    function onERC721Received(
        address operator,
        address from,
        uint256 tokenId,
        bytes calldata data
    ) external returns (bytes4);
}

contract ERC721 is IERC721 {
    using Strings for uint256;

    mapping(uint256 => address) private _owners;
    mapping(address => uint256) private _balances;
    mapping(uint256 => address) private _tokenApprovals;
    mapping(address => mapping(address => bool)) private _operatorApprovals;
    
    function balanceOf(address owner) public view virtual override returns (uint256) {
        require(owner != address(0), "ERC721: balance query for the zero address");
        return _balances[owner];
    }
    
    function ownerOf(uint256 tokenId) public view virtual override returns (address) {
        address owner = _owners[tokenId];
        require(owner != address(0), "ERC721: owner query for nonexistent token");
        return owner;
    }
    
    function _baseURI() internal view virtual returns (string memory) {
        return "";
    }
    
    function approve(address to, uint256 tokenId) public virtual override {
        address owner = ERC721.ownerOf(tokenId);
        require(to != owner, "ERC721: approval to current owner");

        require(
            msg.sender == owner || isApprovedForAll(owner, msg.sender),
            "ERC721: approve caller is not owner nor approved for all"
        );

        _approve(to, tokenId);
    }
    
    function getApproved(uint256 tokenId) public view virtual override returns (address) {
        require(_exists(tokenId), "ERC721: approved query for nonexistent token");

        return _tokenApprovals[tokenId];
    }
    
    function setApprovalForAll(address operator, bool approved) public virtual override {
        require(operator != msg.sender, "ERC721: approve to caller");

        _operatorApprovals[msg.sender][operator] = approved;
        emit ApprovalForAll(msg.sender, operator, approved);
    }
    
    function _isContract(address account) internal view returns (bool) {
        uint256 size;
        assembly {
            size := extcodesize(account)
        }
        return size > 0;
    }
    
    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {
        return _operatorApprovals[owner][operator];
    }
    
    function transferFrom(
        address from,
        address to,
        uint256 tokenId
    ) public virtual override {
        //solhint-disable-next-line max-line-length
        require(_isApprovedOrOwner(msg.sender, tokenId), "ERC721: transfer caller is not owner nor approved");

        _transfer(from, to, tokenId);
    }
    
    function safeTransferFrom(
        address from,
        address to,
        uint256 tokenId
    ) public virtual override {
        safeTransferFrom(from, to, tokenId, "");
    }

    /**
     * @dev See {IERC721-safeTransferFrom}.
     */
    function safeTransferFrom(
        address from,
        address to,
        uint256 tokenId,
        bytes memory _data
    ) public virtual override {
        require(_isApprovedOrOwner(msg.sender, tokenId), "ERC721: transfer caller is not owner nor approved");
        _safeTransfer(from, to, tokenId, _data);
    }

    /**
     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients
     * are aware of the ERC721 protocol to prevent tokens from being forever locked.
     *
     * `_data` is additional data, it has no specified format and it is sent in call to `to`.
     *
     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.
     * implement alternative mechanisms to perform token transfer, such as signature-based.
     *
     * Requirements:
     *
     * - `from` cannot be the zero address.
     * - `to` cannot be the zero address.
     * - `tokenId` token must exist and be owned by `from`.
     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
     *
     * Emits a {Transfer} event.
     */
    function _safeTransfer(
        address from,
        address to,
        uint256 tokenId,
        bytes memory _data
    ) internal virtual {
        _transfer(from, to, tokenId);
        require(_checkOnERC721Received(from, to, tokenId, _data), "ERC721: transfer to non ERC721Receiver implementer");
    }

    /**
     * @dev Returns whether `tokenId` exists.
     *
     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.
     *
     * Tokens start existing when they are minted (`_mint`),
     * and stop existing when they are burned (`_burn`).
     */
    function _exists(uint256 tokenId) internal view virtual returns (bool) {
        return _owners[tokenId] != address(0);
    }

    /**
     * @dev Returns whether `spender` is allowed to manage `tokenId`.
     *
     * Requirements:
     *
     * - `tokenId` must exist.
     */
    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {
        require(_exists(tokenId), "ERC721: operator query for nonexistent token");
        address owner = ERC721.ownerOf(tokenId);
        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));
    }

    /**
     * @dev Safely mints `tokenId` and transfers it to `to`.
     *
     * Requirements:
     *
     * - `tokenId` must not exist.
     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
     *
     * Emits a {Transfer} event.
     */
    function _safeMint(address to, uint256 tokenId) internal virtual {
        _safeMint(to, tokenId, "");
    }

    /**
     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is
     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.
     */
    function _safeMint(
        address to,
        uint256 tokenId,
        bytes memory _data
    ) internal virtual {
        _mint(to, tokenId);
        require(
            _checkOnERC721Received(address(0), to, tokenId, _data),
            "ERC721: transfer to non ERC721Receiver implementer"
        );
    }

    /**
     * @dev Mints `tokenId` and transfers it to `to`.
     *
     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible
     *
     * Requirements:
     *
     * - `tokenId` must not exist.
     * - `to` cannot be the zero address.
     *
     * Emits a {Transfer} event.
     */
    function _mint(address to, uint256 tokenId) internal virtual {
        require(to != address(0), "ERC721: mint to the zero address");
        require(!_exists(tokenId), "ERC721: token already minted");

        _beforeTokenTransfer(address(0), to, tokenId);

        _balances[to] += 1;
        _owners[tokenId] = to;

        emit Transfer(address(0), to, tokenId);
    }

    /**
     * @dev Destroys `tokenId`.
     * The approval is cleared when the token is burned.
     *
     * Requirements:
     *
     * - `tokenId` must exist.
     *
     * Emits a {Transfer} event.
     */
    function _burn(uint256 tokenId) internal virtual {
        address owner = ERC721.ownerOf(tokenId);

        _beforeTokenTransfer(owner, address(0), tokenId);

        // Clear approvals
        _approve(address(0), tokenId);

        _balances[owner] -= 1;
        delete _owners[tokenId];

        emit Transfer(owner, address(0), tokenId);
    }

    /**
     * @dev Transfers `tokenId` from `from` to `to`.
     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.
     *
     * Requirements:
     *
     * - `to` cannot be the zero address.
     * - `tokenId` token must be owned by `from`.
     *
     * Emits a {Transfer} event.
     */
    function _transfer(
        address from,
        address to,
        uint256 tokenId
    ) internal virtual {
        require(ERC721.ownerOf(tokenId) == from, "ERC721: transfer of token that is not own");
        require(to != address(0), "ERC721: transfer to the zero address");

        _beforeTokenTransfer(from, to, tokenId);

        // Clear approvals from the previous owner
        _approve(address(0), tokenId);

        _balances[from] -= 1;
        _balances[to] += 1;
        _owners[tokenId] = to;

        emit Transfer(from, to, tokenId);
    }

    /**
     * @dev Approve `to` to operate on `tokenId`
     *
     * Emits a {Approval} event.
     */
    function _approve(address to, uint256 tokenId) internal virtual {
        _tokenApprovals[tokenId] = to;
        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);
    }

    /**
     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.
     * The call is not executed if the target address is not a contract.
     *
     * @param from address representing the previous owner of the given token ID
     * @param to target address that will receive the tokens
     * @param tokenId uint256 ID of the token to be transferred
     * @param _data bytes optional data to send along with the call
     * @return bool whether the call correctly returned the expected magic value
     */
    function _checkOnERC721Received(
        address from,
        address to,
        uint256 tokenId,
        bytes memory _data
    ) private returns (bool) {
        if (_isContract(to)) {
            try IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, _data) returns (bytes4 retval) {
                return retval == IERC721Receiver(to).onERC721Received.selector;
            } catch (bytes memory reason) {
                if (reason.length == 0) {
                    revert("ERC721: transfer to non ERC721Receiver implementer");
                } else {
                    assembly {
                        revert(add(32, reason), mload(reason))
                    }
                }
            }
        } else {
            return true;
        }
    }

    /**
     * @dev Hook that is called before any token transfer. This includes minting
     * and burning.
     *
     * Calling conditions:
     *
     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be
     * transferred to `to`.
     * - When `from` is zero, `tokenId` will be minted for `to`.
     * - When `to` is zero, ``from``'s `tokenId` will be burned.
     * - `from` and `to` are never both zero.
     *
     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
     */
    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 tokenId
    ) internal virtual {}
}


/**
 * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension
 * @dev See https://eips.ethereum.org/EIPS/eip-721
 */
interface IERC721Enumerable is IERC721 {
    /**
     * @dev Returns the total amount of tokens stored by the contract.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.
     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.
     */
    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);

    /**
     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.
     * Use along with {totalSupply} to enumerate all tokens.
     */
    function tokenByIndex(uint256 index) external view returns (uint256);
}


/**
 * @dev This implements an optional extension of {ERC721} defined in the EIP that adds
 * enumerability of all the token ids in the contract as well as all token ids owned by each
 * account.
 */
abstract contract ERC721Enumerable is ERC721, IERC721Enumerable {
    // Mapping from owner to list of owned token IDs
    mapping(address => mapping(uint256 => uint256)) private _ownedTokens;

    // Mapping from token ID to index of the owner tokens list
    mapping(uint256 => uint256) private _ownedTokensIndex;

    // Array with all token ids, used for enumeration
    uint256[] private _allTokens;

    // Mapping from token id to position in the allTokens array
    mapping(uint256 => uint256) private _allTokensIndex;

    /**
     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.
     */
    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {
        require(index < ERC721.balanceOf(owner), "ERC721Enumerable: owner index out of bounds");
        return _ownedTokens[owner][index];
    }

    /**
     * @dev See {IERC721Enumerable-totalSupply}.
     */
    function totalSupply() public view virtual override returns (uint256) {
        return _allTokens.length;
    }

    /**
     * @dev See {IERC721Enumerable-tokenByIndex}.
     */
    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {
        require(index < ERC721Enumerable.totalSupply(), "ERC721Enumerable: global index out of bounds");
        return _allTokens[index];
    }

    /**
     * @dev Hook that is called before any token transfer. This includes minting
     * and burning.
     *
     * Calling conditions:
     *
     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be
     * transferred to `to`.
     * - When `from` is zero, `tokenId` will be minted for `to`.
     * - When `to` is zero, ``from``'s `tokenId` will be burned.
     * - `from` cannot be the zero address.
     * - `to` cannot be the zero address.
     *
     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
     */
    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 tokenId
    ) internal virtual override {
        super._beforeTokenTransfer(from, to, tokenId);

        if (from == address(0)) {
            _addTokenToAllTokensEnumeration(tokenId);
        } else if (from != to) {
            _removeTokenFromOwnerEnumeration(from, tokenId);
        }
        if (to == address(0)) {
            _removeTokenFromAllTokensEnumeration(tokenId);
        } else if (to != from) {
            _addTokenToOwnerEnumeration(to, tokenId);
        }
    }

    /**
     * @dev Private function to add a token to this extension's ownership-tracking data structures.
     * @param to address representing the new owner of the given token ID
     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address
     */
    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {
        uint256 length = ERC721.balanceOf(to);
        _ownedTokens[to][length] = tokenId;
        _ownedTokensIndex[tokenId] = length;
    }

    /**
     * @dev Private function to add a token to this extension's token tracking data structures.
     * @param tokenId uint256 ID of the token to be added to the tokens list
     */
    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {
        _allTokensIndex[tokenId] = _allTokens.length;
        _allTokens.push(tokenId);
    }

    /**
     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that
     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for
     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).
     * This has O(1) time complexity, but alters the order of the _ownedTokens array.
     * @param from address representing the previous owner of the given token ID
     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address
     */
    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {
        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and
        // then delete the last slot (swap and pop).

        uint256 lastTokenIndex = ERC721.balanceOf(from) - 1;
        uint256 tokenIndex = _ownedTokensIndex[tokenId];

        // When the token to delete is the last token, the swap operation is unnecessary
        if (tokenIndex != lastTokenIndex) {
            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];

            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token
            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index
        }

        // This also deletes the contents at the last position of the array
        delete _ownedTokensIndex[tokenId];
        delete _ownedTokens[from][lastTokenIndex];
    }

    /**
     * @dev Private function to remove a token from this extension's token tracking data structures.
     * This has O(1) time complexity, but alters the order of the _allTokens array.
     * @param tokenId uint256 ID of the token to be removed from the tokens list
     */
    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {
        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and
        // then delete the last slot (swap and pop).

        uint256 lastTokenIndex = _allTokens.length - 1;
        uint256 tokenIndex = _allTokensIndex[tokenId];

        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so
        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding
        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)
        uint256 lastTokenId = _allTokens[lastTokenIndex];

        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token
        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index

        // This also deletes the contents at the last position of the array
        delete _allTokensIndex[tokenId];
        _allTokens.pop();
    }
}



//---------------------------------------------------------------------------------------------------------------------
//Badge
//https://github.com/ra-phael/badge-token/tree/main/contracts/withoutTimestamp

interface IBadge {
	// @dev Emitted when `tokenId` token is minted to `to`, an address.
	event Minted(
		address indexed to,
		uint32 indexed tokenId,
		uint256 timestamp
	);

	// @dev Emitted when `tokenId` token is burned.
	event Burned(
		address indexed owner,
		uint32 indexed tokenId,
		uint256 timestamp
	);

	// @dev Returns the badge's name
	function name() external view returns (string memory);

	// @dev Returns the badge's symbol.
	function symbol() external view returns (string memory);

	// @dev Returns the ID of the token owned by `owner`, if it owns one, and 0 otherwise
	//function tokenOf(address owner) external view returns (bytes32);

	// @dev Returns the owner of the `tokenId` token.
	//function ownerOf(bytes32 tokenId) external view returns (address);
}

contract Badge is IBadge {
	// Badge's name
	string private _name;

	// Badge's symbol
	string private _symbol;

	// Mapping from token ID to owner's address
	mapping(uint32 => address) private _owners;

	// Mapping from owner's address to token ID
	mapping(address => uint32) private _tokens;

	constructor(string memory name_, string memory symbol_) {
		_name = name_;
		_symbol = symbol_;
	}

	// Returns the badge's name
	function name() public view virtual override returns (string memory) {
		return _name;
	}

	// Returns the badge's symbol
	function symbol() public view virtual override returns (string memory) {
		return _symbol;
	}

	// Returns the token ID owned by `owner`, if it exists, and 0 otherwise
	function tokenOf(address owner)
		public
		view
		virtual
		//override
		returns (uint32)
	{
		require(owner != address(0), "Invalid owner at zero address");

		return _tokens[owner];
	}

	// Returns the owner of a given token ID, reverts if the token does not exist
	function ownerOf(uint32 tokenId)
		public
		view
		virtual
		//override
		returns (address)
	{
		require(tokenId != 0, "Invalid tokenId value");

		address owner = _owners[tokenId];

		require(owner != address(0), "Invalid owner at zero address");

		return owner;
	}

	// Checks if a token ID exists
	function _exists(uint32 tokenId) internal view virtual returns (bool) {
		return _owners[tokenId] != address(0);
	}

	// @dev Mints `tokenId` and transfers it to `to`.
	function _mint(address to, uint32 tokenId) internal virtual {
		require(to != address(0), "Invalid owner at zero address");
		//require(tokenId != 0, "Token ID cannot be zero");
		require(!_exists(tokenId), "Token already minted");
		require(tokenOf(to) == 0, "Owner already has a token");

		_tokens[to] = tokenId;
		_owners[tokenId] = to;

		emit Minted(to, tokenId, block.timestamp);
	}

	// @dev Burns `tokenId`.
	function _burn(uint32 tokenId) internal virtual {
		address owner = Badge.ownerOf(tokenId);

		delete _tokens[owner];
		delete _owners[tokenId];

		emit Burned(owner, tokenId, block.timestamp);
	}
}



//---------------------------------------------------------------------------------------------------------------------
//Ownable

/**
 * @dev Provides information about the current execution context, including the
 * sender of the transaction and its data. While these are generally available
 * via msg.sender and msg.data, they should not be accessed in such a direct
 * manner, since when dealing with meta-transactions the account sending and
 * paying for execution may not be the actual sender (as far as an application
 * is concerned).
 *
 * This contract is only required for intermediate, library-like contracts.
 */
abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}

/**
 * @dev Contract module which provides a basic access control mechanism, where
 * there is an account (an owner) that can be granted exclusive access to
 * specific functions.
 *
 * By default, the owner account will be the one that deploys the contract. This
 * can later be changed with {transferOwnership}.
 *
 * This module is used through inheritance. It will make available the modifier
 * `onlyOwner`, which can be applied to your functions to restrict their use to
 * the owner.
 */
abstract contract Ownable is Context {
    address private _owner;
    RandomDataGuard internal _rdg;
    string internal _planetsBaseURI;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /**
     * @dev Initializes the contract setting the deployer as the initial owner.
     */
    constructor() {
        _setOwner(_msgSender());
    }

    /**
     * @dev Returns the address of the current owner.
     */
    function owner() public view virtual returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        require(owner() == _msgSender(), "Ownable: caller is not the owner");
        _;
    }
    
    function setRDG(address rdg)public virtual onlyOwner {
        _rdg = RandomDataGuard(rdg);    
    }

    function setBaseURI(string memory pBaseURI)public virtual onlyOwner {
        _planetsBaseURI = pBaseURI;    
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        _setOwner(newOwner);
    }

    function _setOwner(address newOwner) private {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}

interface RandomDataGuard {
    function randomGuard(uint256 random) external view returns(uint256);
}



//---------------------------------------------------------------------------------------------------------------------
//Base64

/// [MIT License]
/// @title Base64
/// @notice Provides a function for encoding some bytes in base64
/// @author Brecht Devos <brecht@loopring.org>
library Base64 {
    bytes internal constant TABLE = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

    /// @notice Encodes some bytes to the base64 representation
    function encode(bytes memory data) internal pure returns (string memory) {
        uint256 len = data.length;
        if (len == 0) return "";

        // multiply by 4/3 rounded up
        uint256 encodedLen = 4 * ((len + 2) / 3);

        // Add some extra buffer at the end
        bytes memory result = new bytes(encodedLen + 32);

        bytes memory table = TABLE;

        assembly {
            let tablePtr := add(table, 1)
            let resultPtr := add(result, 32)

            for {
                let i := 0
            } lt(i, len) {

            } {
                i := add(i, 3)
                let input := and(mload(add(data, i)), 0xffffff)

                let out := mload(add(tablePtr, and(shr(18, input), 0x3F)))
                out := shl(8, out)
                out := add(out, and(mload(add(tablePtr, and(shr(12, input), 0x3F))), 0xFF))
                out := shl(8, out)
                out := add(out, and(mload(add(tablePtr, and(shr(6, input), 0x3F))), 0xFF))
                out := shl(8, out)
                out := add(out, and(mload(add(tablePtr, and(input, 0x3F))), 0xFF))
                out := shl(224, out)

                mstore(resultPtr, out)

                resultPtr := add(resultPtr, 4)
            }

            switch mod(len, 3)
            case 1 {
                mstore(sub(resultPtr, 2), shl(240, 0x3d3d))
            }
            case 2 {
                mstore(sub(resultPtr, 1), shl(248, 0x3d))
            }

            mstore(result, encodedLen)
        }

        return string(result);
    }
}



//---------------------------------------------------------------------------------------------------------------------
//Murasaki Main

contract Murasaki_Main is Badge, Ownable{

    //address
    address public murasaki_function_address;

    //admin, set address
    function _set_murasaki_function_address(address _address) public onlyOwner {
        murasaki_function_address = _address;
    }

    //names
    string constant internal _name = "House of Murasaki-san";
    string constant internal _symbol = "HMS";
    constructor(
    ) Badge(_name, _symbol) {}

    //static status
    mapping(uint32 => uint32) public class;
    mapping(uint32 => uint32) public summoned_time;

    //variants     
    uint32 public next_summoner = 1;

    //summon
    function summon(address _owner, uint32 _class) external returns (uint32) {
        require(msg.sender == murasaki_function_address);
        uint32 _now = uint32(block.timestamp);
        uint32 _summoning_summoner = next_summoner;
        class[_summoning_summoner] = _class;
        summoned_time[_summoning_summoner] = _now;
        //mint
        next_summoner++;
        _mint(_owner, _summoning_summoner);
        //return summoned summoner_id
        return _summoning_summoner;
    }

    //URI
    //Inspired by OraclizeAPI's implementation - MIT license
    //https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol
    function toString(uint256 value) internal pure returns (string memory) {
        if (value == 0) {
            return "0";
        }
        uint256 temp = value;
        uint256 digits;
        while (temp != 0) {
            digits++;
            temp /= 10;
        }
        bytes memory buffer = new bytes(digits);
        while (value != 0) {
            digits -= 1;
            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));
            value /= 10;
        }
        return string(buffer);
    }
    function tokenURI (uint32 _summoner) public view returns (string memory) {
        string[9] memory parts;
        parts[0] = '<svg xmlns="http://www.w3.org/2000/svg" preserveAspectRatio="xMinYMin meet" viewBox="0 0 350 350"><style>.base { fill: white; font-family: serif; font-size: 14px; }</style><rect width="100%" height="100%" fill="black" /><text x="10" y="20" class="base">';
        parts[1] = string(abi.encodePacked("id", " ", toString(_summoner)));
        parts[2] = '</text><text x="10" y="40" class="base">';
        parts[3] = string(abi.encodePacked("class", " ", toString(class[_summoner])));
        parts[4] = '</text><text x="10" y="60" class="base">';
        parts[5] = string(abi.encodePacked("summoned time", " ", toString(summoned_time[_summoner])));
        parts[6] = '</text></svg>';
        string memory output = 
            string(abi.encodePacked(parts[0], parts[1], parts[2], parts[3], parts[4], parts[5], parts[6]));
        string memory json = Base64.encode(bytes(string(abi.encodePacked('{"name": "summoner #', toString(_summoner), '", "description": "House of Murasaki-san. Murasaki-san is a pet living in your wallet. They grow with your dedication. https://www.murasaki-san.com/", "image": "data:image/svg+xml;base64,', Base64.encode(bytes(output)), '"}'))));
        output = string(abi.encodePacked('data:application/json;base64,', json));
        return output;
    }
}



//---------------------------------------------------------------------------------------------------------------------
//Murasaki Function

contract Murasaki_Function_Share is Ownable {

    //address
    address public murasaki_main_address;
    address public murasaki_strage_address;

    //admin
    function _set1_murasaki_main_address(address _address) external onlyOwner {
        murasaki_main_address = _address;
    }
    function _set2_murasaki_strage_address(address _address) external onlyOwner {
        murasaki_strage_address = _address;
    }

    //transfer coin, material
    function transfer_coin(uint32 _summoner_from, uint32 _summoner_to, uint32 _coin) external {
        Murasaki_Main mm = Murasaki_Main(murasaki_main_address);
        Murasaki_Strage ms = Murasaki_Strage(murasaki_strage_address);
        require(mm.ownerOf(_summoner_from) == msg.sender);
        require(ms.coin(_summoner_from) >= _coin);
        ms.set_coin(_summoner_from, ms.coin(_summoner_from) - _coin);
        ms.set_coin(_summoner_to, ms.coin(_summoner_to) + _coin);
    }
    function transfer_material(uint32 _summoner_from, uint32 _summoner_to, uint32 _material) external {
        Murasaki_Main mm = Murasaki_Main(murasaki_main_address);
        Murasaki_Strage ms = Murasaki_Strage(murasaki_strage_address);
        require(mm.ownerOf(_summoner_from) == msg.sender);
        require(ms.material(_summoner_from) >= _material);
        ms.set_material(_summoner_from, ms.material(_summoner_from) - _material);
        ms.set_material(_summoner_to, ms.material(_summoner_to) + _material);
    }

    //calc satiety
    function calc_satiety(uint32 _summoner) public view returns (uint32) {
        Murasaki_Strage ms = Murasaki_Strage(murasaki_strage_address);
        uint32 SPEED = ms.SPEED();
        uint32 BASE_SEC = ms.BASE_SEC();
        uint32 _now = uint32(block.timestamp);
        uint32 _delta_sec = _now - ms.last_feeding_time(_summoner);
        uint32 _base = BASE_SEC /2 /SPEED;
        uint32 _satiety;
        if (_delta_sec >= _base) {
            _satiety = 0;
        }else {
            _satiety = 100 * (_base - _delta_sec) / _base;
        }
        return _satiety;
    }

    //calc happy
    function calc_happy(uint32 _summoner) public view returns (uint32) {
        Murasaki_Strage ms = Murasaki_Strage(murasaki_strage_address);
        uint32 SPEED = ms.SPEED();
        uint32 BASE_SEC = ms.BASE_SEC();
        uint32 _now = uint32(block.timestamp);
        uint32 _delta_sec = _now - ms.last_grooming_time(_summoner);
        uint32 _base = BASE_SEC *3 /SPEED;
        uint32 _happy;
        if (_delta_sec >= _base) {
            _happy = 0;
        }else {
            _happy = 100 * (_base - _delta_sec) / _base;
        }
        return _happy;
    }

    //random
    //for block chain
    function d100(uint _summoner) external view returns (uint32) {
        return dn(_summoner, 100);
    }
    /*
    // for remix
    function d100(uint _summoner) external pure returns (uint) {
        return _summoner * 0 + 10;
    }
    */
    function d20(uint _summoner) external view returns (uint32) {
        return dn(_summoner, 20);
    }    
    function d12(uint _summoner) external view returns (uint32) {
        return dn(_summoner, 12);
    }    
    function d10(uint _summoner) external view returns (uint32) {
        return dn(_summoner, 10);
    }
    function d8(uint _summoner) external view returns (uint32) {
        return dn(_summoner, 8);
    }
    function d6(uint _summoner) external view returns (uint32) {
        return dn(_summoner, 6);
    }
    function d4(uint _summoner) external view returns (uint32) {
        return dn(_summoner, 4);
    }
    function dn(uint _summoner, uint32 _number) public view returns (uint32) {
        return uint32(_seed(_summoner) % _number);
    }
    function _random(string memory input) internal pure returns (uint256) {
        return uint256(keccak256(abi.encodePacked(input)));
    }
    function _seed(uint _summoner) internal view returns (uint rand) {
        rand = _random(
            string(
                abi.encodePacked(
                    block.timestamp,
                    blockhash(block.number - 1),
                    _summoner,
                    msg.sender
                )
            )
        );
    }
}

//=========================================================================================================

contract Murasaki_Function_Summon_and_LevelUp is Ownable {

    //address
    address public murasaki_main_address;
    address public murasaki_strage_address;

    //admin
    function _set1_murasaki_main_address(address _address) external onlyOwner {
        murasaki_main_address = _address;
    }
    function _set2_murasaki_strage_address(address _address) external onlyOwner {
        murasaki_strage_address = _address;
    }

    //admin. withdraw
    function withdraw(address rec)public onlyOwner{
        payable(rec).transfer(address(this).balance);
    }

    //summon
    function summon(uint32 _class) external payable {
        Murasaki_Main mm = Murasaki_Main(murasaki_main_address);
        Murasaki_Strage ms = Murasaki_Strage(murasaki_strage_address);
        uint32 PRICE = ms.PRICE();
        uint32 BASE_SEC = ms.BASE_SEC();
        require(msg.value >= PRICE);
        require(0 <= _class && _class <= 11);
        //summon on mm, mint NTT
        uint32 _summoner = mm.summon(msg.sender, _class);
        //summon on ms, initialize sutatus
        uint32 _now = uint32(block.timestamp);
        ms.set_level(_summoner, 1);
        ms.set_exp(_summoner, 0);
        ms.set_strength(_summoner, 300);
        ms.set_dexterity(_summoner, 300);
        ms.set_intelligence(_summoner, 300);
        ms.set_luck(_summoner, 300);
        ms.set_next_exp_required(_summoner, 1000);
        ms.set_last_level_up_time(_summoner, _now);
        ms.set_coin(_summoner, 0);
        ms.set_material(_summoner, 0);
        ms.set_last_feeding_time(_summoner, _now - BASE_SEC/4);
        ms.set_last_grooming_time(_summoner, _now - BASE_SEC/4);
        ms.set_mining_status(_summoner, 0);
        ms.set_mining_start_time(_summoner, 0);
        ms.set_farming_status(_summoner, 0);
        ms.set_farming_start_time(_summoner, 0);
        ms.set_crafting_status(_summoner, 0);
        ms.set_crafting_start_time(_summoner, 0);
        ms.set_crafting_item_type(_summoner, 0);
        ms.set_total_mining_sec(_summoner, 0);
        ms.set_total_farming_sec(_summoner, 0);
        ms.set_total_crafting_sec(_summoner, 0);
        ms.set_last_total_mining_sec(_summoner, 0);
        ms.set_last_total_farming_sec(_summoner, 0);
        ms.set_last_total_crafting_sec(_summoner, 0);
        ms.set_last_grooming_time_plus_working_time(_summoner, _now - BASE_SEC/4);
    }

    //level-up
    function level_up(uint32 _summoner) external {
        Murasaki_Main mm = Murasaki_Main(murasaki_main_address);
        Murasaki_Strage ms = Murasaki_Strage(murasaki_strage_address);
        require(mm.ownerOf(_summoner) == msg.sender);
        require(ms.mining_status(_summoner) == 0 && ms.farming_status(_summoner) == 0 && ms.crafting_status(_summoner) == 0);
        require(ms.exp(_summoner) >= ms.next_exp_required(_summoner));
        uint32 _now = uint32(block.timestamp);
        //calculate working percent
        uint32 _base_sec = _now - ms.last_level_up_time(_summoner);
        uint32 _resting_sec = _base_sec
             - ms.last_total_mining_sec(_summoner)
             - ms.last_total_farming_sec(_summoner)
             - ms.last_total_crafting_sec(_summoner);
        uint32 _percent_mining = 400 * (ms.last_total_mining_sec(_summoner) + _resting_sec/4) / _base_sec;
        uint32 _percent_farming = 400 * (ms.last_total_farming_sec(_summoner) + _resting_sec/4) / _base_sec;
        uint32 _percent_crafting = 400 * (ms.last_total_crafting_sec(_summoner) + _resting_sec/4) / _base_sec;
        uint32 _percent_resting = 400 * (_resting_sec/4) / _base_sec;
        //status addition
        ms.set_strength(_summoner, ms.strength(_summoner) + _percent_mining);
        ms.set_dexterity(_summoner, ms.dexterity(_summoner) + _percent_farming);
        ms.set_intelligence(_summoner, ms.intelligence(_summoner) + _percent_crafting);
        ms.set_luck(_summoner, ms.luck(_summoner) + _percent_resting);
        //update timestamp
        ms.set_last_total_mining_sec(_summoner, 0);
        ms.set_last_total_farming_sec(_summoner, 0);
        ms.set_last_total_crafting_sec(_summoner, 0);
        //reset feeding, grooming, and exp
        ms.set_last_feeding_time(_summoner, _now);
        ms.set_last_grooming_time(_summoner, _now);
        ms.set_exp(_summoner, 0);
        //level-up
        uint32 _next_level = ms.level(_summoner) + 1;
        ms.set_level(_summoner, _next_level);
        ms.set_last_level_up_time(_summoner, _now);
        //update next_exp_required
        if (_next_level == 2) {
            ms.set_next_exp_required(_summoner, 3000);
        }else if (_next_level == 3) {
            ms.set_next_exp_required(_summoner, 6000);
        }else if (_next_level == 4) {
            ms.set_next_exp_required(_summoner, 10000);
        }else if (_next_level == 5) {
            ms.set_next_exp_required(_summoner, 15000);
        }else if (_next_level == 6) {
            ms.set_next_exp_required(_summoner, 21000);
        }else if (_next_level == 7) {
            ms.set_next_exp_required(_summoner, 28000);
        }else if (_next_level == 8) {
            ms.set_next_exp_required(_summoner, 36000);
        }else if (_next_level == 9) {
            ms.set_next_exp_required(_summoner, 45000);
        }else if (_next_level == 10) {
            ms.set_next_exp_required(_summoner, 55000);
        }else if (_next_level == 11) {
            ms.set_next_exp_required(_summoner, 66000);
        }else if (_next_level == 12) {
            ms.set_next_exp_required(_summoner, 78000);
        }else if (_next_level == 13) {
            ms.set_next_exp_required(_summoner, 91000);
        }else if (_next_level == 14) {
            ms.set_next_exp_required(_summoner, 105000);
        }else if (_next_level == 15) {
            ms.set_next_exp_required(_summoner, 120000);
        }else if (_next_level == 16) {
            ms.set_next_exp_required(_summoner, 136000);
        }else if (_next_level == 17) {
            ms.set_next_exp_required(_summoner, 153000);
        }else if (_next_level == 18) {
            ms.set_next_exp_required(_summoner, 171000);
        }else if (_next_level == 19) {
            ms.set_next_exp_required(_summoner, 190000);
        }
    }
}

//=========================================================================================================

contract Murasaki_Function_Feeding_and_Grooming is Ownable {

    //address
    address public murasaki_main_address;
    address public murasaki_strage_address;
    address public murasaki_function_share_address;

    //admin
    function _set1_murasaki_main_address(address _address) external onlyOwner {
        murasaki_main_address = _address;
    }
    function _set2_murasaki_strage_address(address _address) external onlyOwner {
        murasaki_strage_address = _address;
    }
    function _set3_murasaki_function_share_address(address _address) external onlyOwner {
        murasaki_function_share_address = _address;
    }

    //admin. withdraw
    function withdraw(address rec)public onlyOwner{
        payable(rec).transfer(address(this).balance);
    }

    //feeding
    function feeding(uint32 _summoner) external returns (uint32){
        Murasaki_Main mm = Murasaki_Main(murasaki_main_address);
        Murasaki_Strage ms = Murasaki_Strage(murasaki_strage_address);
        Murasaki_Function_Share mfs = Murasaki_Function_Share(murasaki_function_share_address);
        require(mm.ownerOf(_summoner) == msg.sender);
        require(not_petrified(_summoner));
        uint32 _now = uint32(block.timestamp);
        uint32 _satiety = mfs.calc_satiety(_summoner);
        uint32 _exp_add = 500 * (100 - _satiety) / 100;
        //luck challenge
        if (mfs.d100(_summoner) <= ms.luck(_summoner)/100) {
            _exp_add = _exp_add *2;
        }
        uint32 _exp = ms.exp(_summoner) + _exp_add;
        ms.set_exp(_summoner, _exp);
        ms.set_last_feeding_time(_summoner, _now);
        return _exp_add;
    }

    //petrification, debends on only feeding
    function not_petrified(uint32 _summoner) public view returns (bool) {
        Murasaki_Strage ms = Murasaki_Strage(murasaki_strage_address);
        uint32 SPEED = ms.SPEED();
        uint32 BASE_SEC = ms.BASE_SEC();
        uint32 _now = uint32(block.timestamp);
        uint32 _delta_sec = _now - ms.last_feeding_time(_summoner);
        if ( _delta_sec >= BASE_SEC * 30 / SPEED) {
            return false;
        }else {
            return true;
        }
    }
    function cure_petrification(uint32 _summoner) external payable {
        Murasaki_Main mm = Murasaki_Main(murasaki_main_address);
        Murasaki_Strage ms = Murasaki_Strage(murasaki_strage_address);
        require(mm.ownerOf(_summoner) == msg.sender);
        require(!not_petrified(_summoner));
        uint _price = ms.level(_summoner) * 10 ether;
        require(msg.value >= _price);
        uint32 _now = uint32(block.timestamp);
        ms.set_last_feeding_time(_summoner, _now);
        ms.set_mining_status(_summoner, 0);
        ms.set_farming_status(_summoner, 0);
        ms.set_crafting_status(_summoner, 0);
    }

    //grooming
    function grooming(uint32 _summoner) external returns (uint32){
        Murasaki_Main mm = Murasaki_Main(murasaki_main_address);
        Murasaki_Strage ms = Murasaki_Strage(murasaki_strage_address);
        Murasaki_Function_Share mfs = Murasaki_Function_Share(murasaki_function_share_address);
        require(mm.ownerOf(_summoner) == msg.sender);
        require(not_petrified(_summoner));
        require(ms.mining_status(_summoner) == 0 && ms.farming_status(_summoner) == 0 && ms.crafting_status(_summoner) == 0);
        uint32 _now = uint32(block.timestamp);
        uint32 _happy = mfs.calc_happy(_summoner);
        uint32 _exp_add = 3000 * (100 - _happy) / 100;
        //luck challenge
        if (mfs.d100(_summoner) <= ms.luck(_summoner)/100) {
            _exp_add = _exp_add *2;
        }
        uint32 _exp = ms.exp(_summoner) + _exp_add;
        ms.set_exp(_summoner, _exp);
        ms.set_last_grooming_time(_summoner, _now);
        return _exp_add;
    }
}

//=========================================================================================================

contract Murasaki_Function_Mining_and_Farming is Ownable {

    //address
    address public murasaki_main_address;
    address public murasaki_strage_address;
    address public murasaki_function_share_address;
    address public murasaki_craft_address;
    address public world_dice_address;

    //admin
    function _set1_murasaki_main_address(address _address) external onlyOwner {
        murasaki_main_address = _address;
    }
    function _set2_murasaki_strage_address(address _address) external onlyOwner {
        murasaki_strage_address = _address;
    }
    function _set3_murasaki_function_share_address(address _address) external onlyOwner {
        murasaki_function_share_address = _address;
    }
    function _set4_murasaki_craft_address(address _address) external onlyOwner {
        murasaki_craft_address = _address;
    }
    function _set5_world_dice_address(address _address) external onlyOwner {
        world_dice_address = _address;
    }

    //mining
    function start_mining(uint32 _summoner) external {
        Murasaki_Main mm = Murasaki_Main(murasaki_main_address);
        Murasaki_Strage ms = Murasaki_Strage(murasaki_strage_address);
        Murasaki_Function_Share mfs = Murasaki_Function_Share(murasaki_function_share_address);
        require(mm.ownerOf(_summoner) == msg.sender);
        require(ms.mining_status(_summoner) == 0 && ms.farming_status(_summoner) == 0 && ms.crafting_status(_summoner) == 0);
        require(mfs.calc_satiety(_summoner) >= 20 && mfs.calc_happy(_summoner) >= 20);
        require(ms.level(_summoner) >= 2);
        uint32 _now = uint32(block.timestamp);
        ms.set_mining_status(_summoner, 1);
        ms.set_mining_start_time(_summoner, _now);
    }
    function stop_mining(uint32 _summoner) external returns (uint32) {
        Murasaki_Main mm = Murasaki_Main(murasaki_main_address);
        Murasaki_Strage ms = Murasaki_Strage(murasaki_strage_address);
        Murasaki_Function_Share mfs = Murasaki_Function_Share(murasaki_function_share_address);
        require(mm.ownerOf(_summoner) == msg.sender);
        require(ms.mining_status(_summoner) == 1);
        uint32 _now = uint32(block.timestamp);
        uint32 _delta = calc_mining(_summoner);
        //luck modification
        if (mfs.d100(_summoner) <= ms.luck(_summoner)/100) {
            _delta = _delta *2;
        }
        //add coin
        uint32 _coin = ms.coin(_summoner) + _delta;
        ms.set_coin(_summoner, _coin);
        //update timestamp
        uint32 _delta_sec = _now - ms.mining_start_time(_summoner);
        uint32 _total_mining_sec = ms.total_mining_sec(_summoner) + _delta_sec;
        ms.set_total_mining_sec(_summoner, _total_mining_sec);
        uint32 _last_total_mining_sec = ms.last_total_mining_sec(_summoner) + _delta_sec;
        ms.set_last_total_mining_sec(_summoner, _last_total_mining_sec);
        uint32 _last_grooming_time_plus_working_time = ms.last_grooming_time_plus_working_time(_summoner) + _delta_sec;
        ms.set_last_grooming_time_plus_working_time(_summoner, _last_grooming_time_plus_working_time);
        ms.set_mining_status(_summoner, 0);
        return _delta;
    }
    function calc_mining(uint32 _summoner) public view returns (uint32) {
        Murasaki_Strage ms = Murasaki_Strage(murasaki_strage_address);
        uint32 SPEED = ms.SPEED();
        require(ms.mining_status(_summoner) == 1);
        uint32 _now = uint32(block.timestamp);
        uint32 _delta = (_now - ms.mining_start_time(_summoner)) * SPEED / 100;
        //status, level, item boost
        uint32 _mod = ms.strength(_summoner)/100 + ms.level(_summoner) + count_mining_items(msg.sender);
        //world dice boost
        World_Dice wd = World_Dice(world_dice_address);
        uint32 _rolled_dice = wd.get_rolled_dice(_summoner);
        _mod += _rolled_dice;
        //1 point = 4%
        _mod *= 2;
        //boost
        _delta += _delta * _mod / 100;
        return _delta;
    }
    function count_mining_items(address _address) public view returns (uint32) {
        Murasaki_Craft mc = Murasaki_Craft(murasaki_craft_address);
        uint32[128] memory _balance_of_type = mc.get_balance_of_type(_address);
        uint32 _mining_items = 0;
        for (uint i = 1; i <= 16; i++) {
            if (_balance_of_type[i+64] > 0) {
                _mining_items += 2;
            }else if (_balance_of_type[i] > 0) {
                _mining_items += 1;
            }
        }
        return _mining_items;
    }

    //farming
    function start_farming(uint32 _summoner) external {
        Murasaki_Main mm = Murasaki_Main(murasaki_main_address);
        Murasaki_Strage ms = Murasaki_Strage(murasaki_strage_address);
        Murasaki_Function_Share mfs = Murasaki_Function_Share(murasaki_function_share_address);
        require(mm.ownerOf(_summoner) == msg.sender);
        require(ms.mining_status(_summoner) == 0 && ms.farming_status(_summoner) == 0 && ms.crafting_status(_summoner) == 0);
        require(mfs.calc_satiety(_summoner) >= 20 && mfs.calc_happy(_summoner) >= 20);
        require(ms.level(_summoner) >= 2);
        uint32 _now = uint32(block.timestamp);
        ms.set_farming_status(_summoner, 1);
        ms.set_farming_start_time(_summoner, _now);
    }
    function stop_farming(uint32 _summoner) external returns (uint32){
        Murasaki_Main mm = Murasaki_Main(murasaki_main_address);
        Murasaki_Strage ms = Murasaki_Strage(murasaki_strage_address);
        Murasaki_Function_Share mfs = Murasaki_Function_Share(murasaki_function_share_address);
        require(mm.ownerOf(_summoner) == msg.sender);
        require(ms.farming_status(_summoner) == 1);
        uint32 _now = uint32(block.timestamp);
        uint32 _delta = calc_farming(_summoner);
        //luck modification
        if (mfs.d100(_summoner) <= ms.luck(_summoner)/100) {
            _delta = _delta *2;
        }
        //add coin
        uint32 _material = ms.material(_summoner) + _delta;
        ms.set_material(_summoner, _material);
        //update timestamp
        uint32 _delta_sec = _now - ms.farming_start_time(_summoner);
        uint32 _total_farming_sec = ms.total_farming_sec(_summoner) + _delta_sec;
        ms.set_total_farming_sec(_summoner, _total_farming_sec);
        uint32 _last_total_farming_sec = ms.last_total_farming_sec(_summoner) + _delta_sec;
        ms.set_last_total_farming_sec(_summoner, _last_total_farming_sec);
        uint32 _last_grooming_time_plus_working_time = ms.last_grooming_time_plus_working_time(_summoner) + _delta_sec;
        ms.set_last_grooming_time_plus_working_time(_summoner, _last_grooming_time_plus_working_time);
        ms.set_farming_status(_summoner, 0);
        return _delta;
    }
    function calc_farming(uint32 _summoner) public view returns (uint32) {
        Murasaki_Strage ms = Murasaki_Strage(murasaki_strage_address);
        uint32 SPEED = ms.SPEED();
        require(ms.farming_status(_summoner) == 1);
        uint32 _now = uint32(block.timestamp);
        uint32 _delta = (_now - ms.farming_start_time(_summoner)) * SPEED / 1000;
        //status and item boost
        uint32 _mod = ms.dexterity(_summoner)/100 + ms.level(_summoner) + count_farming_items(msg.sender);
        //world dice boost
        World_Dice wd = World_Dice(world_dice_address);
        uint32 _rolled_dice = wd.get_rolled_dice(_summoner);
        _mod += _rolled_dice;
        //1 point = 4%
        _mod *= 2;
        //boost
        _delta += _delta * _mod / 100;
        return _delta;
    }
    function count_farming_items(address _address) public view returns (uint32) {
        Murasaki_Craft mc = Murasaki_Craft(murasaki_craft_address);
        uint32[128] memory _balance_of_type = mc.get_balance_of_type(_address);
        uint32 _farming_items = 0;
        for (uint i = 17; i <= 32; i++) {
            if (_balance_of_type[i+64] > 0) {
                _farming_items += 2;
            }else if (_balance_of_type[i] > 0) {
                _farming_items += 1;
            }
        }
        return _farming_items;
    }
}

//=========================================================================================================

contract Murasaki_Function_Crafting is Ownable {

    //address
    address public murasaki_main_address;
    address public murasaki_strage_address;
    address public murasaki_function_share_address;
    address public murasaki_craft_address;
    address public world_dice_address;

    //admin
    function _set1_murasaki_main_address(address _address) external onlyOwner {
        murasaki_main_address = _address;
    }
    function _set2_murasaki_strage_address(address _address) external onlyOwner {
        murasaki_strage_address = _address;
    }
    function _set3_murasaki_function_share_address(address _address) external onlyOwner {
        murasaki_function_share_address = _address;
    }
    function _set4_murasaki_craft_address(address _address) external onlyOwner {
        murasaki_craft_address = _address;
    }
    function _set5_world_dice_address(address _address) external onlyOwner {
        world_dice_address = _address;
    }

    //crafting
    function start_crafting(uint32 _summoner, uint32 _item_type) public {
        Murasaki_Main mm = Murasaki_Main(murasaki_main_address);
        Murasaki_Strage ms = Murasaki_Strage(murasaki_strage_address);
        Murasaki_Function_Share mfs = Murasaki_Function_Share(murasaki_function_share_address);
        require(mm.ownerOf(_summoner) == msg.sender);
        require(ms.mining_status(_summoner) == 0 && ms.farming_status(_summoner) == 0 && ms.crafting_status(_summoner) == 0);
        require(mfs.calc_satiety(_summoner) >= 20 && mfs.calc_happy(_summoner) >= 20);
        require(ms.level(_summoner) >= 3);
        require(_item_type <= 63);
        uint32 _now = uint32(block.timestamp);
        //check coin and material
        Murasaki_Craft mc = Murasaki_Craft(murasaki_craft_address);
        uint32[3] memory _dc_table = mc.get_item_dc(_item_type);
        uint32 _coin = _dc_table[1];
        uint32 _material = _dc_table[2];
        require(ms.coin(_summoner) >= _coin && ms.material(_summoner) >= _material);
        //start crafting
        ms.set_coin(_summoner, ms.coin(_summoner) - _coin);
        ms.set_material(_summoner, ms.material(_summoner) - _material);
        ms.set_crafting_item_type(_summoner, _item_type);
        ms.set_crafting_status(_summoner, 1);
        ms.set_crafting_start_time(_summoner, _now);
    }
    function stop_crafting(uint32 _summoner) public {
        Murasaki_Main mm = Murasaki_Main(murasaki_main_address);
        Murasaki_Strage ms = Murasaki_Strage(murasaki_strage_address);
        Murasaki_Function_Share mfs = Murasaki_Function_Share(murasaki_function_share_address);
        require(mm.ownerOf(_summoner) == msg.sender);
        require(ms.crafting_status(_summoner) == 1);
        uint32 _now = uint32(block.timestamp);
        uint32 _delta_sec = (_now - ms.crafting_start_time(_summoner));
        uint32 _item_type = ms.crafting_item_type(_summoner);
        //stop
        ms.set_total_crafting_sec(_summoner, ms.total_crafting_sec(_summoner) + _delta_sec);
        ms.set_last_total_crafting_sec(_summoner, ms.last_total_crafting_sec(_summoner) + _delta_sec);
        ms.set_last_grooming_time_plus_working_time(
            _summoner, ms.last_grooming_time_plus_working_time(_summoner) + _delta_sec);
        //craft
        uint32 _calc_crafting = calc_crafting(_summoner);
        ms.set_crafting_status(_summoner, 0);   //before tx, required status must be updated
        if (_calc_crafting == 0) {
            //rare challenge
            if (mfs.d100(_summoner) <= ms.luck(_summoner)/100) {
                _item_type += 64;
            }
            //craft
            Murasaki_Craft mc = Murasaki_Craft(murasaki_craft_address);
            mc.craft(_item_type, _summoner, msg.sender);
        }
    }
    function calc_crafting(uint32 _summoner) public view returns (uint32) {
        Murasaki_Strage ms = Murasaki_Strage(murasaki_strage_address);
        require(ms.crafting_status(_summoner) == 1);
        uint32 SPEED = ms.SPEED();
        uint32 _now = uint32(block.timestamp);
        uint32 _item_type = ms.crafting_item_type(_summoner);
        uint32 _delta_time = ( _now - ms.crafting_start_time(_summoner) ) * SPEED;
        //dc
        Murasaki_Craft mc = Murasaki_Craft(murasaki_craft_address);
        uint32[3] memory _dc_table = mc.get_item_dc(_item_type);
        uint32 _dc = _dc_table[0];
        //status boost
        uint32 _mod = ms.intelligence(_summoner)/100 + ms.level(_summoner) + count_crafting_items(msg.sender);
        //world dice boost
        World_Dice wd = World_Dice(world_dice_address);
        uint32 _rolled_dice = wd.get_rolled_dice(_summoner);
        _mod += _rolled_dice;
        //1 point = 4%
        _mod *= 2;
        //_mod is not over 80 ***TODO***
        if (_mod > 80) {
            _mod = 80;
        }
        _dc -= _dc * _mod / 100;
        uint32 _delta;
        if (_delta_time >= _dc) {
            _delta = 0;
        }else {
            _delta = _dc - _delta_time;
        }
        return _delta;
    }
    function count_crafting_items(address _address) public view returns (uint32) {
        Murasaki_Craft mc = Murasaki_Craft(murasaki_craft_address);
        uint32[128] memory _balance_of_type = mc.get_balance_of_type(_address);
        uint32 _crafting_items = 0;
        for (uint i = 33; i <= 48; i++) {
            if (_balance_of_type[i+64] > 0) {
                _crafting_items += 2;
            }else if (_balance_of_type[i] > 0) {
                _crafting_items += 1;
            }
        }
        return _crafting_items;
    }
}



//---------------------------------------------------------------------------------------------------------------------
//Murasaki Craft

contract Murasaki_Craft is ERC721, Ownable{

    //address
    address public murasaki_function_address;

    //admin
    function _set_murasaki_function_address(address _address) public onlyOwner{
        murasaki_function_address = _address;
    }

    //name
    string constant public name = "Murasaki Craft";
    string constant public symbol = "MC";

    //global variants
    uint32 public next_item = 1;
    struct item {
        uint32 item_type;
        uint32 crafted_time;
        uint32 crafted_summoner;
        address crafted_wallet;
    }
    mapping(uint256 => item) public items;
    mapping(address => uint32[128]) public balance_of_type;

    //override ERC721 transfer, 
    function _transfer(
        address from,
        address to,
        uint256 tokenId
    ) internal virtual override {
        ERC721._transfer(from, to, tokenId);
        uint32 _item_type = items[tokenId].item_type;
        balance_of_type[from][_item_type] -= 1;
        balance_of_type[to][_item_type] += 1;
    }

    //override ERC721 burn
    function _burn(uint256 tokenId) internal virtual override {
        ERC721._burn(tokenId);
        uint32 _item_type = items[tokenId].item_type;
        address _owner = ERC721.ownerOf(tokenId);
        balance_of_type[_owner][_item_type] -= 1;
    }

    //call items as array
    function get_balance_of_type(address _wallet) public view returns (uint32[128] memory) {
        return balance_of_type[_wallet];
    }

    //get item dc
    function get_item_dc(uint32 _item_type) public view returns (uint32[3] memory) {
        uint32 _dc = dc_table[_item_type];
        uint32 _coin = coin_table[_item_type];
        uint32 _material = material_table[_item_type];
        return [_dc, _coin, _material];
    }

    //craft
    function craft(uint32 _item_type, uint32 _summoner, address _wallet) external {
        require(msg.sender == murasaki_function_address);
        uint32 _now = uint32(block.timestamp);
        uint32 _crafting_item = next_item;
        items[_crafting_item] = item(_item_type, _now, _summoner, _wallet);
        balance_of_type[_wallet][_item_type] += 1;  //balanceOf each item type
        next_item++;
        _safeMint(_wallet, _crafting_item);
    }  

    //URI
    //Inspired by OraclizeAPI's implementation - MIT license
    //https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol
    function toString(uint256 value) internal pure returns (string memory) {
        if (value == 0) {
            return "0";
        }
        uint256 temp = value;
        uint256 digits;
        while (temp != 0) {
            digits++;
            temp /= 10;
        }
        bytes memory buffer = new bytes(digits);
        while (value != 0) {
            digits -= 1;
            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));
            value /= 10;
        }
        return string(buffer);
    }
    function tokenURI (uint32 _item) public view returns (string memory) {
        string[9] memory parts;
        parts[0] = '<svg xmlns="http://www.w3.org/2000/svg" preserveAspectRatio="xMinYMin meet" viewBox="0 0 350 350"><style>.base { fill: white; font-family: serif; font-size: 14px; }</style><rect width="100%" height="100%" fill="black" /><text x="10" y="20" class="base">';
        parts[1] = string(abi.encodePacked("id", " ", toString(_item)));
        parts[2] = '</text><text x="10" y="40" class="base">';
        parts[3] = string(abi.encodePacked("type", " ", toString(items[_item].item_type)));
        parts[4] = '</text><text x="10" y="60" class="base">';
        parts[5] = string(abi.encodePacked("crafted time", " ", toString(items[_item].crafted_time)));
        parts[6] = '</text><text x="10" y="80" class="base">';
        parts[7] = string(abi.encodePacked("crafted summoner", " ", toString(items[_item].crafted_summoner)));
        parts[8] = '</text></svg>';
        string memory output = 
            string(abi.encodePacked(parts[0], parts[1], parts[2], parts[3], parts[4], parts[5], parts[6], parts[7], parts[8]));
        string memory json = Base64.encode(bytes(string(abi.encodePacked('{"name": "summoner #', toString(_item), '", "description": "House of Murasaki-san. Murasaki-san is a pet living in your wallet. They grow with your dedication. https://www.murasaki-san.com/", "image": "data:image/svg+xml;base64,', Base64.encode(bytes(output)), '"}'))));
        output = string(abi.encodePacked('data:application/json;base64,', json));
        return output;
    }

    //item dc
    uint32[64] public dc_table = [
        //0:dummy
        0,
        //1-16: mining item
        100000,
        300000,
        600000,
        1000000,
        1500000,
        2100000,
        2800000,
        3600000,
        4500000,
        5500000,
        6600000,
        7800000,
        9100000,
        10500000,
        12000000,
        13600000,
        //17-32: farming item
        100000,
        300000,
        600000,
        1000000,
        1500000,
        2100000,
        2800000,
        3600000,
        4500000,
        5500000,
        6600000,
        7800000,
        9100000,
        10500000,
        12000000,
        13600000,
        //33-48: crafting item
        100000,
        300000,
        600000,
        1000000,
        1500000,
        2100000,
        2800000,
        3600000,
        4500000,
        5500000,
        6600000,
        7800000,
        9100000,
        10500000,
        12000000,
        13600000,
        //49: pet
        100000,
        //50: ,musicbox
        300000,
        //51: ,world dice
        300000,
        //52-63: unreserved
        1000,
        1000,
        1000,
        1000,
        1000,
        1000,
        1000,
        1000,
        1000,
        1000,
        1000,
        1000
    ];
    //item coin
    uint32[64] public coin_table = [
        //0:dummy
        0,
        //1-16: mining item
        1000,
        3000,
        6000,
        10000,
        15000,
        21000,
        28000,
        36000,
        45000,
        55000,
        66000,
        78000,
        91000,
        105000,
        120000,
        136000,
        //17-32: farming item
        1000,
        3000,
        6000,
        10000,
        15000,
        21000,
        28000,
        36000,
        45000,
        55000,
        66000,
        78000,
        91000,
        105000,
        120000,
        136000,
        //33-48: crafting item
        1000,
        3000,
        6000,
        10000,
        15000,
        21000,
        28000,
        36000,
        45000,
        55000,
        66000,
        78000,
        91000,
        105000,
        120000,
        136000,
        //49: pet
        1000,
        //50: muscibox
        3000,
        //51: world dice
        3000,
        //52-63: unreserved
        100,
        100,
        100,
        100,
        100,
        100,
        100,
        100,
        100,
        100,
        100,
        100
    ];
    //item material
    uint32[64] public material_table = [
        //0:dummy
        0,
        //1-16: mining item
        100,
        300,
        600,
        1000,
        1500,
        2100,
        2800,
        3600,
        4500,
        5500,
        6600,
        7800,
        9100,
        10500,
        12000,
        13600,
        //17-32: farming item
        100,
        300,
        600,
        1000,
        1500,
        2100,
        2800,
        3600,
        4500,
        5500,
        6600,
        7800,
        9100,
        10500,
        12000,
        13600,
        //33-48: crafting item
        100,
        300,
        600,
        1000,
        1500,
        2100,
        2800,
        3600,
        4500,
        5500,
        6600,
        7800,
        9100,
        10500,
        12000,
        13600,
        //49: pet
        100,
        //50: musicbox
        300,
        //51: world dice
        600,
        //50-63: unreserved
        10,
        10,
        10,
        10,
        10,
        10,
        10,
        10,
        10,
        10,
        10,
        10
    ];      
}



//---------------------------------------------------------------------------------------------------------------------
//world dice

contract World_Dice is Ownable {

    //address
    address public murasaki_main_address;
    address public murasaki_strage_address;
    address public murasaki_function_share_address;
    address public murasaki_craft_address;

    //admin
    function _set1_murasaki_main_address(address _address) external onlyOwner {
        murasaki_main_address = _address;
    }
    function _set2_murasaki_strage_address(address _address) external onlyOwner {
        murasaki_strage_address = _address;
    }
    function _set3_murasaki_function_share_address(address _address) external onlyOwner {
        murasaki_function_share_address = _address;
    }
    function _set4_murasaki_craft_address(address _address) external onlyOwner {
        murasaki_craft_address = _address;
    }

    //variants
    mapping(uint32 => uint32) public rolled_dice;
    mapping(uint32 => uint32) public last_dice_roll_time;

    //dice roll
    function dice_roll(uint32 _summoner) external {
        Murasaki_Main mm = Murasaki_Main(murasaki_main_address);
        Murasaki_Strage ms = Murasaki_Strage(murasaki_strage_address);
        Murasaki_Function_Share mfs = Murasaki_Function_Share(murasaki_function_share_address);
        Murasaki_Craft mc = Murasaki_Craft(murasaki_craft_address);
        require(mm.ownerOf(_summoner) == msg.sender);
        //dice possession check
        address _owner = mm.ownerOf(_summoner);
        require(mc.balance_of_type(_owner, 51) > 0);
        //last_dice_roll_time check, can roll after BASE_SEC * 0.9
        uint32 _now = uint32(block.timestamp);
        require(_now - last_dice_roll_time[_summoner] >= (ms.BASE_SEC() *9/10) / ms.SPEED());
        //dice roll
        uint32 _dice_roll = mfs.d20(_summoner);
        //luck challenge
        if (mfs.d100(_summoner) <= ms.luck(_summoner)/100) {
            _dice_roll = 20;
        }
        rolled_dice[_summoner] = _dice_roll;
        last_dice_roll_time[_summoner] = _now;
    }

    //get rolled dice
    function get_rolled_dice(uint32 _summoner) external view returns (uint32) {
        Murasaki_Strage ms = Murasaki_Strage(murasaki_strage_address);
        uint32 _now = uint32(block.timestamp);
        //ignore past rolled dice before BASE_SEC
        if(_now - last_dice_roll_time[_summoner] >= ms.BASE_SEC() / ms.SPEED()) {
            return 0;
        } else{
            return rolled_dice[_summoner];
        }
    }
}



//---------------------------------------------------------------------------------------------------------------------
//Murasaki Strage

contract Murasaki_Strage is Ownable {

    //permitted address
    mapping(address => bool) public permitted_address;

    //admin, add or remove permitted_address
    function _add_permitted_address(address _address) external onlyOwner {
        permitted_address[_address] = true;
    }
    function _remove_permitted_address(address _address) external onlyOwner {
        permitted_address[_address] = false;
    }

    //global variants
    uint32 public BASE_SEC = 86400;
    uint32 public SPEED = 24;
    uint32 public PRICE = 0 ether;    

    //dynamic, status
    mapping(uint32 => uint32) public level;
    mapping(uint32 => uint32) public exp;
    mapping(uint32 => uint32) public strength;
    mapping(uint32 => uint32) public dexterity;
    mapping(uint32 => uint32) public intelligence;
    mapping(uint32 => uint32) public luck;
    mapping(uint32 => uint32) public next_exp_required;
    mapping(uint32 => uint32) public last_level_up_time;

    //dymanic, resouse
    mapping(uint32 => uint32) public coin;
    mapping(uint32 => uint32) public material;

    //dynamic, treating
    mapping(uint32 => uint32) public last_feeding_time;
    mapping(uint32 => uint32) public last_grooming_time;

    //dynamic, working
    mapping(uint32 => uint32) public mining_status;
    mapping(uint32 => uint32) public mining_start_time;
    mapping(uint32 => uint32) public farming_status;
    mapping(uint32 => uint32) public farming_start_time;
    mapping(uint32 => uint32) public crafting_status;
    mapping(uint32 => uint32) public crafting_start_time;
    mapping(uint32 => uint32) public crafting_item_type;
    mapping(uint32 => uint32) public total_mining_sec;
    mapping(uint32 => uint32) public total_farming_sec;
    mapping(uint32 => uint32) public total_crafting_sec;
    mapping(uint32 => uint32) public last_total_mining_sec;
    mapping(uint32 => uint32) public last_total_farming_sec;
    mapping(uint32 => uint32) public last_total_crafting_sec;
    mapping(uint32 => uint32) public last_grooming_time_plus_working_time;

    //items
    //mapping(uint32 => uint32[128]) public items;

    //admin, set global variants
    function _set_base_sec(uint32 _base_sec) external onlyOwner {
        BASE_SEC = _base_sec;
    }
    function _set_speed(uint32 _speed) external onlyOwner {
        SPEED = _speed;
    }
    function set_price(uint8 _price) external onlyOwner {
        PRICE = _price;
    }

    //set status
    function set_level(uint32 _summoner, uint32 _value) external {
        require(permitted_address[msg.sender] == true);
        level[_summoner] = _value;
    }
    function set_exp(uint32 _summoner, uint32 _value) external {
        require(permitted_address[msg.sender] == true);
        exp[_summoner] = _value;
    }
    function set_strength(uint32 _summoner, uint32 _value) external {
        require(permitted_address[msg.sender] == true);
        strength[_summoner] = _value;
    }
    function set_dexterity(uint32 _summoner, uint32 _value) external {
        require(permitted_address[msg.sender] == true);
        dexterity[_summoner] = _value;
    }
    function set_intelligence(uint32 _summoner, uint32 _value) external {
        require(permitted_address[msg.sender] == true);
        intelligence[_summoner] = _value;
    }
    function set_luck(uint32 _summoner, uint32 _value) external {
        require(permitted_address[msg.sender] == true);
        luck[_summoner] = _value;
    }
    function set_next_exp_required(uint32 _summoner, uint32 _value) external {
        require(permitted_address[msg.sender] == true);
        next_exp_required[_summoner] = _value;
    }
    function set_last_level_up_time(uint32 _summoner, uint32 _value) external {
        require(permitted_address[msg.sender] == true);
        last_level_up_time[_summoner] = _value;
    }
    function set_coin(uint32 _summoner, uint32 _value) external {
        require(permitted_address[msg.sender] == true);
        coin[_summoner] = _value;
    }
    function set_material(uint32 _summoner, uint32 _value) external {
        require(permitted_address[msg.sender] == true);
        material[_summoner] = _value;
    }
    function set_last_feeding_time(uint32 _summoner, uint32 _value) external {
        require(permitted_address[msg.sender] == true);
        last_feeding_time[_summoner] = _value;
    }
    function set_last_grooming_time(uint32 _summoner, uint32 _value) external {
        require(permitted_address[msg.sender] == true);
        last_grooming_time[_summoner] = _value;
    }
    function set_mining_status(uint32 _summoner, uint32 _value) external {
        require(permitted_address[msg.sender] == true);
        mining_status[_summoner] = _value;
    }
    function set_mining_start_time(uint32 _summoner, uint32 _value) external {
        require(permitted_address[msg.sender] == true);
        mining_start_time[_summoner] = _value;
    }
    function set_farming_status(uint32 _summoner, uint32 _value) external {
        require(permitted_address[msg.sender] == true);
        farming_status[_summoner] = _value;
    }
    function set_farming_start_time(uint32 _summoner, uint32 _value) external {
        require(permitted_address[msg.sender] == true);
        farming_start_time[_summoner] = _value;
    }
    function set_crafting_status(uint32 _summoner, uint32 _value) external {
        require(permitted_address[msg.sender] == true);
        crafting_status[_summoner] = _value;
    }
    function set_crafting_start_time(uint32 _summoner, uint32 _value) external {
        require(permitted_address[msg.sender] == true);
        crafting_start_time[_summoner] = _value;
    }
    function set_crafting_item_type(uint32 _summoner, uint32 _value) external {
        require(permitted_address[msg.sender] == true);
        crafting_item_type[_summoner] = _value;
    }
    function set_total_mining_sec(uint32 _summoner, uint32 _value) external {
        require(permitted_address[msg.sender] == true);
        total_mining_sec[_summoner] = _value;
    }
    function set_total_farming_sec(uint32 _summoner, uint32 _value) external {
        require(permitted_address[msg.sender] == true);
        total_farming_sec[_summoner] = _value;
    }
    function set_total_crafting_sec(uint32 _summoner, uint32 _value) external {
        require(permitted_address[msg.sender] == true);
        total_crafting_sec[_summoner] = _value;
    }
    function set_last_total_mining_sec(uint32 _summoner, uint32 _value) external {
        require(permitted_address[msg.sender] == true);
        last_total_mining_sec[_summoner] = _value;
    }
    function set_last_total_farming_sec(uint32 _summoner, uint32 _value) external {
        require(permitted_address[msg.sender] == true);
        last_total_farming_sec[_summoner] = _value;
    }
    function set_last_total_crafting_sec(uint32 _summoner, uint32 _value) external {
        require(permitted_address[msg.sender] == true);
        last_total_crafting_sec[_summoner] = _value;
    }
    function set_last_grooming_time_plus_working_time(uint32 _summoner, uint32 _value) external {
        require(permitted_address[msg.sender] == true);
        last_grooming_time_plus_working_time[_summoner] = _value;
    }
}


